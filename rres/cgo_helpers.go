// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Tue, 01 Jun 2021 11:52:25 CST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package rres

/*
#include "../lib/rres/src/rres.h"
#include "../lib/rres/src/rres-raylib.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)
var allocReferenceCount int

func init() {
	allocReferenceCount = 0
}

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	defer a.mux.Unlock()

	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}

	allocReferenceCount++
	fmt.Printf("INFO: MEMORY: [PTR %p] CGO memory alloc\n", ptr)
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	defer a.mux.RUnlock()

	isEmpty := len(a.m) == 0
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}

	b.mux.Lock()
	defer b.mux.Unlock()
	a.mux.Lock()
	defer a.mux.Unlock()

	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	defer a.mux.Unlock()

	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)

		allocReferenceCount--
		fmt.Printf("INFO: MEMORY: [PTR %p] CGO memory free\n", ptr)
	}
}

// allocRresDataChunkMemory allocates memory for type C.rresDataChunk in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRresDataChunkMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRresDataChunkValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRresDataChunkValue = unsafe.Sizeof([1]C.rresDataChunk{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocIntMemory allocates memory for type C.int in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIntMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIntValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfIntValue = unsafe.Sizeof([1]C.int{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSInt32 transforms a sliced Go data structure into plain C format.
func unpackSInt32(x []int32) (unpacked *C.int, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.int) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocIntMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.int)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0] = (C.int)(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.int)(h.Data)
	return
}

// newRresDataChunkRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newRresDataChunkRef(ref unsafe.Pointer) *gRresDataChunk {
	if ref == nil {
		return nil
	}
	obj := new(gRresDataChunk)
	obj.reff705e719 = (*C.rresDataChunk)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gRresDataChunk) passRef() (*C.rresDataChunk, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff705e719 != nil {
		if x.allocsf705e719 != nil {
			return x.reff705e719, x.allocsf705e719.(*cgoAllocMap)
		} else {
			return x.reff705e719, nil
		}
	}
	memf705e719 := unsafe.Pointer(new(C.rresDataChunk))
	reff705e719 := (*C.rresDataChunk)(memf705e719)
	allocsf705e719 := new(cgoAllocMap)
	// allocsf705e719.Add(memf705e719)

	var c_type_allocs *cgoAllocMap
	reff705e719._type, c_type_allocs = (C.uint)(x.gType), cgoAllocsUnknown
	allocsf705e719.Borrow(c_type_allocs)
	x.gType = *new(uint32)

	var cpropsCount_allocs *cgoAllocMap
	reff705e719.propsCount, cpropsCount_allocs = (C.uint)(x.gPropsCount), cgoAllocsUnknown
	allocsf705e719.Borrow(cpropsCount_allocs)
	x.gPropsCount = *new(uint32)

	var cprops_allocs *cgoAllocMap
	reff705e719.props, cprops_allocs = unpackSInt32(x.gProps)
	allocsf705e719.Borrow(cprops_allocs)
	x.gProps = *new([]int32)

	var cdata_allocs *cgoAllocMap
	reff705e719.data, cdata_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.gData)), cgoAllocsUnknown
	allocsf705e719.Borrow(cdata_allocs)
	x.gData = *new(unsafe.Pointer)

	x.reff705e719 = reff705e719
	x.allocsf705e719 = allocsf705e719

	return reff705e719, allocsf705e719
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gRresDataChunk) passValue() (C.rresDataChunk, *cgoAllocMap) {
	if x.reff705e719 != nil {
		return *x.reff705e719, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gRresDataChunk) convert() *RresDataChunk {
	if x.reff705e719 != nil {
		return (*RresDataChunk)(unsafe.Pointer(x.reff705e719))
	}
	x.passRef()
	return (*RresDataChunk)(unsafe.Pointer(x.reff705e719))
}

// NewRresDataChunk new Go object and Mapping to C object.
func NewRresDataChunk(cType uint32, cPropsCount uint32, cProps []int32, cData unsafe.Pointer) RresDataChunk {
	obj := *new(gRresDataChunk)
	obj.gType = cType
	obj.gPropsCount = cPropsCount
	obj.gProps = cProps
	obj.gData = cData

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocRresDataChunk.")
	}
	return *(*RresDataChunk)(unsafe.Pointer(ret0))
}

// AllocRresDataChunk new Go object and Mapping to C object.
func AllocRresDataChunk(cType uint32, cPropsCount uint32, cProps []int32, cData unsafe.Pointer) (*RresDataChunk, *cgoAllocMap) {
	obj := *new(gRresDataChunk)
	obj.gType = cType
	obj.gPropsCount = cPropsCount
	obj.gProps = cProps
	obj.gData = cData

	ret0, alloc0 := obj.passRef()
	ret1 := (*RresDataChunk)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *RresDataChunk) Index(index int32) *RresDataChunk {
	ptr1 := (*RresDataChunk)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfrresDataChunkValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *RresDataChunk) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*RresDataChunk) {
			a.Free()
		})
	}
}

// Props returns a reference to C object within a struct
func (x *RresDataChunk) Propser(index int32) *int32 {
	var ret *int32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.int{})
	ptr0 := x.Props
	ptr1 := (*C.int)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfPlainValue)))
	ret = (*int32)(unsafe.Pointer(ptr1))

	return ret
}

// allocRresDataMemory allocates memory for type C.rresData in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRresDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRresDataValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRresDataValue = unsafe.Sizeof([1]C.rresData{})

// unpackSRresDataChunk transforms a sliced Go data structure into plain C format.
func unpackSRresDataChunk(x []gRresDataChunk) (unpacked *C.rresDataChunk, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.rresDataChunk) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRresDataChunkMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.rresDataChunk)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].passValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.rresDataChunk)(h.Data)
	return
}

// newRresDataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newRresDataRef(ref unsafe.Pointer) *gRresData {
	if ref == nil {
		return nil
	}
	obj := new(gRresData)
	obj.ref3a6e0f31 = (*C.rresData)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gRresData) passRef() (*C.rresData, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3a6e0f31 != nil {
		if x.allocs3a6e0f31 != nil {
			return x.ref3a6e0f31, x.allocs3a6e0f31.(*cgoAllocMap)
		} else {
			return x.ref3a6e0f31, nil
		}
	}
	mem3a6e0f31 := unsafe.Pointer(new(C.rresData))
	ref3a6e0f31 := (*C.rresData)(mem3a6e0f31)
	allocs3a6e0f31 := new(cgoAllocMap)
	// allocs3a6e0f31.Add(mem3a6e0f31)

	var ccount_allocs *cgoAllocMap
	ref3a6e0f31.count, ccount_allocs = (C.uint)(x.gCount), cgoAllocsUnknown
	allocs3a6e0f31.Borrow(ccount_allocs)
	x.gCount = *new(uint32)

	var cchunks_allocs *cgoAllocMap
	ref3a6e0f31.chunks, cchunks_allocs = unpackSRresDataChunk(x.gChunks)
	allocs3a6e0f31.Borrow(cchunks_allocs)
	x.gChunks = *new([]gRresDataChunk)

	x.ref3a6e0f31 = ref3a6e0f31
	x.allocs3a6e0f31 = allocs3a6e0f31

	return ref3a6e0f31, allocs3a6e0f31
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gRresData) passValue() (C.rresData, *cgoAllocMap) {
	if x.ref3a6e0f31 != nil {
		return *x.ref3a6e0f31, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gRresData) convert() *RresData {
	if x.ref3a6e0f31 != nil {
		return (*RresData)(unsafe.Pointer(x.ref3a6e0f31))
	}
	x.passRef()
	return (*RresData)(unsafe.Pointer(x.ref3a6e0f31))
}

// NewRresData new Go object and Mapping to C object.
func NewRresData(cCount uint32, cChunks []RresDataChunk) RresData {
	obj := *new(gRresData)
	obj.gCount = cCount

	var chunks0 []gRresDataChunk
	for i0 := range cChunks {
		p0 := *newrresDataChunkRef(unsafe.Pointer(&cChunks[i0]))
		chunks0 = append(chunks0, p0)
	}
	obj.gChunks = chunks0

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocRresData.")
	}
	return *(*RresData)(unsafe.Pointer(ret0))
}

// AllocRresData new Go object and Mapping to C object.
func AllocRresData(cCount uint32, cChunks []RresDataChunk) (*RresData, *cgoAllocMap) {
	obj := *new(gRresData)
	obj.gCount = cCount

	var chunks0 []gRresDataChunk
	for i0 := range cChunks {
		p0 := *newrresDataChunkRef(unsafe.Pointer(&cChunks[i0]))
		chunks0 = append(chunks0, p0)
	}
	obj.gChunks = chunks0

	ret0, alloc0 := obj.passRef()
	ret1 := (*RresData)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *RresData) Index(index int32) *RresData {
	ptr1 := (*RresData)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfrresDataValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *RresData) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*RresData) {
			a.Free()
		})
	}
}

// Chunks returns a reference to C object within a struct
func (x *RresData) Chunkser(index int32) *RresDataChunk {
	var ret *RresDataChunk

	ptr0 := x.Chunks
	ptr1 := (*C.rresDataChunk)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfRresDataChunkValue)))
	ret = newRresDataChunkRef(unsafe.Pointer(ptr1)).convert()

	return ret
}

// allocRresDirEntryMemory allocates memory for type C.rresDirEntry in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRresDirEntryMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRresDirEntryValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRresDirEntryValue = unsafe.Sizeof([1]C.rresDirEntry{})

// newRresDirEntryRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newRresDirEntryRef(ref unsafe.Pointer) *gRresDirEntry {
	if ref == nil {
		return nil
	}
	obj := new(gRresDirEntry)
	obj.ref32db2e90 = (*C.rresDirEntry)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gRresDirEntry) passRef() (*C.rresDirEntry, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref32db2e90 != nil {
		if x.allocs32db2e90 != nil {
			return x.ref32db2e90, x.allocs32db2e90.(*cgoAllocMap)
		} else {
			return x.ref32db2e90, nil
		}
	}
	mem32db2e90 := unsafe.Pointer(new(C.rresDirEntry))
	ref32db2e90 := (*C.rresDirEntry)(mem32db2e90)
	allocs32db2e90 := new(cgoAllocMap)
	// allocs32db2e90.Add(mem32db2e90)

	var cid_allocs *cgoAllocMap
	ref32db2e90.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs32db2e90.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var coffset_allocs *cgoAllocMap
	ref32db2e90.offset, coffset_allocs = (C.uint)(x.gOffset), cgoAllocsUnknown
	allocs32db2e90.Borrow(coffset_allocs)
	x.gOffset = *new(uint32)

	var cfileNameLen_allocs *cgoAllocMap
	ref32db2e90.fileNameLen, cfileNameLen_allocs = (C.uint)(x.gFileNameLen), cgoAllocsUnknown
	allocs32db2e90.Borrow(cfileNameLen_allocs)
	x.gFileNameLen = *new(uint32)

	var cfileName_allocs *cgoAllocMap
	ref32db2e90.fileName, cfileName_allocs = *(*[512]C.char)(unsafe.Pointer(&x.gFileName)), cgoAllocsUnknown
	allocs32db2e90.Borrow(cfileName_allocs)
	x.gFileName = *new([512]byte)

	x.ref32db2e90 = ref32db2e90
	x.allocs32db2e90 = allocs32db2e90

	return ref32db2e90, allocs32db2e90
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gRresDirEntry) passValue() (C.rresDirEntry, *cgoAllocMap) {
	if x.ref32db2e90 != nil {
		return *x.ref32db2e90, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gRresDirEntry) convert() *RresDirEntry {
	if x.ref32db2e90 != nil {
		return (*RresDirEntry)(unsafe.Pointer(x.ref32db2e90))
	}
	x.passRef()
	return (*RresDirEntry)(unsafe.Pointer(x.ref32db2e90))
}

// NewRresDirEntry new Go object and Mapping to C object.
func NewRresDirEntry(cId uint32, cOffset uint32, cFileNameLen uint32, cFileName [512]byte) RresDirEntry {
	obj := *new(gRresDirEntry)
	obj.gId = cId
	obj.gOffset = cOffset
	obj.gFileNameLen = cFileNameLen
	obj.gFileName = cFileName

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocRresDirEntry.")
	}
	return *(*RresDirEntry)(unsafe.Pointer(ret0))
}

// AllocRresDirEntry new Go object and Mapping to C object.
func AllocRresDirEntry(cId uint32, cOffset uint32, cFileNameLen uint32, cFileName [512]byte) (*RresDirEntry, *cgoAllocMap) {
	obj := *new(gRresDirEntry)
	obj.gId = cId
	obj.gOffset = cOffset
	obj.gFileNameLen = cFileNameLen
	obj.gFileName = cFileName

	ret0, alloc0 := obj.passRef()
	ret1 := (*RresDirEntry)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *RresDirEntry) Index(index int32) *RresDirEntry {
	ptr1 := (*RresDirEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfrresDirEntryValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *RresDirEntry) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*RresDirEntry) {
			a.Free()
		})
	}
}

// FileName returns a reference to C object within a struct

// allocRresCentralDirMemory allocates memory for type C.rresCentralDir in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRresCentralDirMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRresCentralDirValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRresCentralDirValue = unsafe.Sizeof([1]C.rresCentralDir{})

// unpackSRresDirEntry transforms a sliced Go data structure into plain C format.
func unpackSRresDirEntry(x []gRresDirEntry) (unpacked *C.rresDirEntry, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.rresDirEntry) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRresDirEntryMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.rresDirEntry)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].passValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.rresDirEntry)(h.Data)
	return
}

// newRresCentralDirRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newRresCentralDirRef(ref unsafe.Pointer) *gRresCentralDir {
	if ref == nil {
		return nil
	}
	obj := new(gRresCentralDir)
	obj.ref87f3899d = (*C.rresCentralDir)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gRresCentralDir) passRef() (*C.rresCentralDir, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref87f3899d != nil {
		if x.allocs87f3899d != nil {
			return x.ref87f3899d, x.allocs87f3899d.(*cgoAllocMap)
		} else {
			return x.ref87f3899d, nil
		}
	}
	mem87f3899d := unsafe.Pointer(new(C.rresCentralDir))
	ref87f3899d := (*C.rresCentralDir)(mem87f3899d)
	allocs87f3899d := new(cgoAllocMap)
	// allocs87f3899d.Add(mem87f3899d)

	var ccount_allocs *cgoAllocMap
	ref87f3899d.count, ccount_allocs = (C.uint)(x.gCount), cgoAllocsUnknown
	allocs87f3899d.Borrow(ccount_allocs)
	x.gCount = *new(uint32)

	var centries_allocs *cgoAllocMap
	ref87f3899d.entries, centries_allocs = unpackSRresDirEntry(x.gEntries)
	allocs87f3899d.Borrow(centries_allocs)
	x.gEntries = *new([]gRresDirEntry)

	x.ref87f3899d = ref87f3899d
	x.allocs87f3899d = allocs87f3899d

	return ref87f3899d, allocs87f3899d
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gRresCentralDir) passValue() (C.rresCentralDir, *cgoAllocMap) {
	if x.ref87f3899d != nil {
		return *x.ref87f3899d, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gRresCentralDir) convert() *RresCentralDir {
	if x.ref87f3899d != nil {
		return (*RresCentralDir)(unsafe.Pointer(x.ref87f3899d))
	}
	x.passRef()
	return (*RresCentralDir)(unsafe.Pointer(x.ref87f3899d))
}

// NewRresCentralDir new Go object and Mapping to C object.
func NewRresCentralDir(cCount uint32, cEntries []RresDirEntry) RresCentralDir {
	obj := *new(gRresCentralDir)
	obj.gCount = cCount

	var entries0 []gRresDirEntry
	for i0 := range cEntries {
		p0 := *newrresDirEntryRef(unsafe.Pointer(&cEntries[i0]))
		entries0 = append(entries0, p0)
	}
	obj.gEntries = entries0

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocRresCentralDir.")
	}
	return *(*RresCentralDir)(unsafe.Pointer(ret0))
}

// AllocRresCentralDir new Go object and Mapping to C object.
func AllocRresCentralDir(cCount uint32, cEntries []RresDirEntry) (*RresCentralDir, *cgoAllocMap) {
	obj := *new(gRresCentralDir)
	obj.gCount = cCount

	var entries0 []gRresDirEntry
	for i0 := range cEntries {
		p0 := *newrresDirEntryRef(unsafe.Pointer(&cEntries[i0]))
		entries0 = append(entries0, p0)
	}
	obj.gEntries = entries0

	ret0, alloc0 := obj.passRef()
	ret1 := (*RresCentralDir)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *RresCentralDir) Index(index int32) *RresCentralDir {
	ptr1 := (*RresCentralDir)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfrresCentralDirValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *RresCentralDir) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*RresCentralDir) {
			a.Free()
		})
	}
}

// Entries returns a reference to C object within a struct
func (x *RresCentralDir) Entrieser(index int32) *RresDirEntry {
	var ret *RresDirEntry

	ptr0 := x.Entries
	ptr1 := (*C.rresDirEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfRresDirEntryValue)))
	ret = newRresDirEntryRef(unsafe.Pointer(ptr1)).convert()

	return ret
}

// allocRresFontGlyphsInfoMemory allocates memory for type C.rresFontGlyphsInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRresFontGlyphsInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRresFontGlyphsInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRresFontGlyphsInfoValue = unsafe.Sizeof([1]C.rresFontGlyphsInfo{})

// newRresFontGlyphsInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newRresFontGlyphsInfoRef(ref unsafe.Pointer) *gRresFontGlyphsInfo {
	if ref == nil {
		return nil
	}
	obj := new(gRresFontGlyphsInfo)
	obj.refd91ac199 = (*C.rresFontGlyphsInfo)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gRresFontGlyphsInfo) passRef() (*C.rresFontGlyphsInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd91ac199 != nil {
		if x.allocsd91ac199 != nil {
			return x.refd91ac199, x.allocsd91ac199.(*cgoAllocMap)
		} else {
			return x.refd91ac199, nil
		}
	}
	memd91ac199 := unsafe.Pointer(new(C.rresFontGlyphsInfo))
	refd91ac199 := (*C.rresFontGlyphsInfo)(memd91ac199)
	allocsd91ac199 := new(cgoAllocMap)
	// allocsd91ac199.Add(memd91ac199)

	var cx_allocs *cgoAllocMap
	refd91ac199.x, cx_allocs = (C.int)(x.gX), cgoAllocsUnknown
	allocsd91ac199.Borrow(cx_allocs)
	x.gX = *new(int32)

	var cy_allocs *cgoAllocMap
	refd91ac199.y, cy_allocs = (C.int)(x.gY), cgoAllocsUnknown
	allocsd91ac199.Borrow(cy_allocs)
	x.gY = *new(int32)

	var cwidth_allocs *cgoAllocMap
	refd91ac199.width, cwidth_allocs = (C.int)(x.gWidth), cgoAllocsUnknown
	allocsd91ac199.Borrow(cwidth_allocs)
	x.gWidth = *new(int32)

	var cheight_allocs *cgoAllocMap
	refd91ac199.height, cheight_allocs = (C.int)(x.gHeight), cgoAllocsUnknown
	allocsd91ac199.Borrow(cheight_allocs)
	x.gHeight = *new(int32)

	var cvalue_allocs *cgoAllocMap
	refd91ac199.value, cvalue_allocs = (C.int)(x.gValue), cgoAllocsUnknown
	allocsd91ac199.Borrow(cvalue_allocs)
	x.gValue = *new(int32)

	var coffsetX_allocs *cgoAllocMap
	refd91ac199.offsetX, coffsetX_allocs = (C.int)(x.gOffsetX), cgoAllocsUnknown
	allocsd91ac199.Borrow(coffsetX_allocs)
	x.gOffsetX = *new(int32)

	var coffsetY_allocs *cgoAllocMap
	refd91ac199.offsetY, coffsetY_allocs = (C.int)(x.gOffsetY), cgoAllocsUnknown
	allocsd91ac199.Borrow(coffsetY_allocs)
	x.gOffsetY = *new(int32)

	var cadvanceX_allocs *cgoAllocMap
	refd91ac199.advanceX, cadvanceX_allocs = (C.int)(x.gAdvanceX), cgoAllocsUnknown
	allocsd91ac199.Borrow(cadvanceX_allocs)
	x.gAdvanceX = *new(int32)

	x.refd91ac199 = refd91ac199
	x.allocsd91ac199 = allocsd91ac199

	return refd91ac199, allocsd91ac199
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gRresFontGlyphsInfo) passValue() (C.rresFontGlyphsInfo, *cgoAllocMap) {
	if x.refd91ac199 != nil {
		return *x.refd91ac199, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gRresFontGlyphsInfo) convert() *RresFontGlyphsInfo {
	if x.refd91ac199 != nil {
		return (*RresFontGlyphsInfo)(unsafe.Pointer(x.refd91ac199))
	}
	x.passRef()
	return (*RresFontGlyphsInfo)(unsafe.Pointer(x.refd91ac199))
}

// NewRresFontGlyphsInfo new Go object and Mapping to C object.
func NewRresFontGlyphsInfo(cX int32, cY int32, cWidth int32, cHeight int32, cValue int32, cOffsetX int32, cOffsetY int32, cAdvanceX int32) RresFontGlyphsInfo {
	obj := *new(gRresFontGlyphsInfo)
	obj.gX = cX
	obj.gY = cY
	obj.gWidth = cWidth
	obj.gHeight = cHeight
	obj.gValue = cValue
	obj.gOffsetX = cOffsetX
	obj.gOffsetY = cOffsetY
	obj.gAdvanceX = cAdvanceX

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocRresFontGlyphsInfo.")
	}
	return *(*RresFontGlyphsInfo)(unsafe.Pointer(ret0))
}

// AllocRresFontGlyphsInfo new Go object and Mapping to C object.
func AllocRresFontGlyphsInfo(cX int32, cY int32, cWidth int32, cHeight int32, cValue int32, cOffsetX int32, cOffsetY int32, cAdvanceX int32) (*RresFontGlyphsInfo, *cgoAllocMap) {
	obj := *new(gRresFontGlyphsInfo)
	obj.gX = cX
	obj.gY = cY
	obj.gWidth = cWidth
	obj.gHeight = cHeight
	obj.gValue = cValue
	obj.gOffsetX = cOffsetX
	obj.gOffsetY = cOffsetY
	obj.gAdvanceX = cAdvanceX

	ret0, alloc0 := obj.passRef()
	ret1 := (*RresFontGlyphsInfo)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *RresFontGlyphsInfo) Index(index int32) *RresFontGlyphsInfo {
	ptr1 := (*RresFontGlyphsInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfrresFontGlyphsInfoValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *RresFontGlyphsInfo) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*RresFontGlyphsInfo) {
			a.Free()
		})
	}
}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}
