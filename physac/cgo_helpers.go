// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Thu, 10 Sep 2020 17:34:47 CST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package physac

/*
#include "../lib/raylib/src/physac.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)
var allocReferenceCount int

func init() {
	allocReferenceCount = 0
}

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	defer a.mux.Unlock()

	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}

	allocReferenceCount++
	fmt.Printf("INFO: MEMORY: [PTR %p] CGO memory alloc\n", ptr)
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	defer a.mux.RUnlock()

	isEmpty := len(a.m) == 0
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}

	b.mux.Lock()
	defer b.mux.Unlock()
	a.mux.Lock()
	defer a.mux.Unlock()

	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	defer a.mux.Unlock()

	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)

		allocReferenceCount--
		fmt.Printf("INFO: MEMORY: [PTR %p] CGO memory free\n", ptr)
	}
}

// allocVector2Memory allocates memory for type C.Vector2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector2Value = unsafe.Sizeof([1]C.Vector2{})

// newVector2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newVector2Ref(ref unsafe.Pointer) *gVector2 {
	if ref == nil {
		return nil
	}
	obj := new(gVector2)
	obj.ref29ca61a5 = (*C.Vector2)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gVector2) passRef() (*C.Vector2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref29ca61a5 != nil {
		if x.allocs29ca61a5 != nil {
			return x.ref29ca61a5, x.allocs29ca61a5.(*cgoAllocMap)
		} else {
			return x.ref29ca61a5, nil
		}
	}
	mem29ca61a5 := unsafe.Pointer(new(C.Vector2))
	ref29ca61a5 := (*C.Vector2)(mem29ca61a5)
	allocs29ca61a5 := new(cgoAllocMap)
	// allocs29ca61a5.Add(mem29ca61a5)

	var cx_allocs *cgoAllocMap
	ref29ca61a5.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	ref29ca61a5.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cy_allocs)
	x.gY = *new(float32)

	x.ref29ca61a5 = ref29ca61a5
	x.allocs29ca61a5 = allocs29ca61a5

	return ref29ca61a5, allocs29ca61a5
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gVector2) passValue() (C.Vector2, *cgoAllocMap) {
	if x.ref29ca61a5 != nil {
		return *x.ref29ca61a5, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gVector2) convert() *Vector2 {
	if x.ref29ca61a5 != nil {
		return (*Vector2)(unsafe.Pointer(x.ref29ca61a5))
	}
	x.passRef()
	return (*Vector2)(unsafe.Pointer(x.ref29ca61a5))
}

// NewVector2 new Go object and Mapping to C object.
func NewVector2(cX float32, cY float32) Vector2 {
	obj := *new(gVector2)
	obj.gX = cX
	obj.gY = cY

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocVector2.")
	}
	return *(*Vector2)(unsafe.Pointer(ret0))
}

// AllocVector2 new Go object and Mapping to C object.
func AllocVector2(cX float32, cY float32) (*Vector2, *cgoAllocMap) {
	obj := *new(gVector2)
	obj.gX = cX
	obj.gY = cY

	ret0, alloc0 := obj.passRef()
	ret1 := (*Vector2)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Vector2) Index(index int32) *Vector2 {
	ptr1 := (*Vector2)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfVector2Value)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Vector2) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Vector2) {
			a.Free()
		})
	}
}

// allocMatrix2x2Memory allocates memory for type C.Matrix2x2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMatrix2x2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMatrix2x2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMatrix2x2Value = unsafe.Sizeof([1]C.Matrix2x2{})

// newMatrix2x2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newMatrix2x2Ref(ref unsafe.Pointer) *gMatrix2x2 {
	if ref == nil {
		return nil
	}
	obj := new(gMatrix2x2)
	obj.refb92f06e6 = (*C.Matrix2x2)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gMatrix2x2) passRef() (*C.Matrix2x2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb92f06e6 != nil {
		if x.allocsb92f06e6 != nil {
			return x.refb92f06e6, x.allocsb92f06e6.(*cgoAllocMap)
		} else {
			return x.refb92f06e6, nil
		}
	}
	memb92f06e6 := unsafe.Pointer(new(C.Matrix2x2))
	refb92f06e6 := (*C.Matrix2x2)(memb92f06e6)
	allocsb92f06e6 := new(cgoAllocMap)
	// allocsb92f06e6.Add(memb92f06e6)

	var cm00_allocs *cgoAllocMap
	refb92f06e6.m00, cm00_allocs = (C.float)(x.gM00), cgoAllocsUnknown
	allocsb92f06e6.Borrow(cm00_allocs)
	x.gM00 = *new(float32)

	var cm01_allocs *cgoAllocMap
	refb92f06e6.m01, cm01_allocs = (C.float)(x.gM01), cgoAllocsUnknown
	allocsb92f06e6.Borrow(cm01_allocs)
	x.gM01 = *new(float32)

	var cm10_allocs *cgoAllocMap
	refb92f06e6.m10, cm10_allocs = (C.float)(x.gM10), cgoAllocsUnknown
	allocsb92f06e6.Borrow(cm10_allocs)
	x.gM10 = *new(float32)

	var cm11_allocs *cgoAllocMap
	refb92f06e6.m11, cm11_allocs = (C.float)(x.gM11), cgoAllocsUnknown
	allocsb92f06e6.Borrow(cm11_allocs)
	x.gM11 = *new(float32)

	x.refb92f06e6 = refb92f06e6
	x.allocsb92f06e6 = allocsb92f06e6

	return refb92f06e6, allocsb92f06e6
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gMatrix2x2) passValue() (C.Matrix2x2, *cgoAllocMap) {
	if x.refb92f06e6 != nil {
		return *x.refb92f06e6, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gMatrix2x2) convert() *Matrix2x2 {
	if x.refb92f06e6 != nil {
		return (*Matrix2x2)(unsafe.Pointer(x.refb92f06e6))
	}
	x.passRef()
	return (*Matrix2x2)(unsafe.Pointer(x.refb92f06e6))
}

// NewMatrix2x2 new Go object and Mapping to C object.
func NewMatrix2x2(cM00 float32, cM01 float32, cM10 float32, cM11 float32) Matrix2x2 {
	obj := *new(gMatrix2x2)
	obj.gM00 = cM00
	obj.gM01 = cM01
	obj.gM10 = cM10
	obj.gM11 = cM11

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocMatrix2x2.")
	}
	return *(*Matrix2x2)(unsafe.Pointer(ret0))
}

// AllocMatrix2x2 new Go object and Mapping to C object.
func AllocMatrix2x2(cM00 float32, cM01 float32, cM10 float32, cM11 float32) (*Matrix2x2, *cgoAllocMap) {
	obj := *new(gMatrix2x2)
	obj.gM00 = cM00
	obj.gM01 = cM01
	obj.gM10 = cM10
	obj.gM11 = cM11

	ret0, alloc0 := obj.passRef()
	ret1 := (*Matrix2x2)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Matrix2x2) Index(index int32) *Matrix2x2 {
	ptr1 := (*Matrix2x2)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfMatrix2x2Value)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Matrix2x2) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Matrix2x2) {
			a.Free()
		})
	}
}

// allocPolygonDataMemory allocates memory for type C.PolygonData in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPolygonDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPolygonDataValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPolygonDataValue = unsafe.Sizeof([1]C.PolygonData{})

// allocA24Vector2Memory allocates memory for type [24]C.Vector2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA24Vector2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA24Vector2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA24Vector2Value = unsafe.Sizeof([1][24]C.Vector2{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackA24Vector2 transforms a sliced Go data structure into plain C format.
func unpackA24Vector2(x [24]gVector2) (unpacked [24]C.Vector2, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[24]C.Vector2) {
		go allocs.Free()
	})

	mem0 := allocA24Vector2Memory(1)
	allocs.Add(mem0)
	v0 := (*[24]C.Vector2)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].passValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[24]C.Vector2)(mem0)
	return
}

// newPolygonDataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newPolygonDataRef(ref unsafe.Pointer) *gPolygonData {
	if ref == nil {
		return nil
	}
	obj := new(gPolygonData)
	obj.ref87a94eb7 = (*C.PolygonData)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gPolygonData) passRef() (*C.PolygonData, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref87a94eb7 != nil {
		if x.allocs87a94eb7 != nil {
			return x.ref87a94eb7, x.allocs87a94eb7.(*cgoAllocMap)
		} else {
			return x.ref87a94eb7, nil
		}
	}
	mem87a94eb7 := unsafe.Pointer(new(C.PolygonData))
	ref87a94eb7 := (*C.PolygonData)(mem87a94eb7)
	allocs87a94eb7 := new(cgoAllocMap)
	// allocs87a94eb7.Add(mem87a94eb7)

	var cvertexCount_allocs *cgoAllocMap
	ref87a94eb7.vertexCount, cvertexCount_allocs = (C.uint)(x.gVertexCount), cgoAllocsUnknown
	allocs87a94eb7.Borrow(cvertexCount_allocs)
	x.gVertexCount = *new(uint32)

	var cpositions_allocs *cgoAllocMap
	ref87a94eb7.positions, cpositions_allocs = unpackA24Vector2(x.gPositions)
	allocs87a94eb7.Borrow(cpositions_allocs)
	x.gPositions = *new([24]gVector2)

	var cnormals_allocs *cgoAllocMap
	ref87a94eb7.normals, cnormals_allocs = unpackA24Vector2(x.gNormals)
	allocs87a94eb7.Borrow(cnormals_allocs)
	x.gNormals = *new([24]gVector2)

	x.ref87a94eb7 = ref87a94eb7
	x.allocs87a94eb7 = allocs87a94eb7

	return ref87a94eb7, allocs87a94eb7
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gPolygonData) passValue() (C.PolygonData, *cgoAllocMap) {
	if x.ref87a94eb7 != nil {
		return *x.ref87a94eb7, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gPolygonData) convert() *PolygonData {
	if x.ref87a94eb7 != nil {
		return (*PolygonData)(unsafe.Pointer(x.ref87a94eb7))
	}
	x.passRef()
	return (*PolygonData)(unsafe.Pointer(x.ref87a94eb7))
}

// NewPolygonData new Go object and Mapping to C object.
func NewPolygonData(cVertexCount uint32, cPositions [24]Vector2, cNormals [24]Vector2) PolygonData {
	obj := *new(gPolygonData)
	obj.gVertexCount = cVertexCount

	var positions0 [24]gVector2
	for i0 := range cPositions {
		p0 := *newVector2Ref(unsafe.Pointer(&cPositions[i0]))
		positions0[i0] = p0
	}
	obj.gPositions = positions0

	var normals0 [24]gVector2
	for i0 := range cNormals {
		p0 := *newVector2Ref(unsafe.Pointer(&cNormals[i0]))
		normals0[i0] = p0
	}
	obj.gNormals = normals0

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocPolygonData.")
	}
	return *(*PolygonData)(unsafe.Pointer(ret0))
}

// AllocPolygonData new Go object and Mapping to C object.
func AllocPolygonData(cVertexCount uint32, cPositions [24]Vector2, cNormals [24]Vector2) (*PolygonData, *cgoAllocMap) {
	obj := *new(gPolygonData)
	obj.gVertexCount = cVertexCount

	var positions0 [24]gVector2
	for i0 := range cPositions {
		p0 := *newVector2Ref(unsafe.Pointer(&cPositions[i0]))
		positions0[i0] = p0
	}
	obj.gPositions = positions0

	var normals0 [24]gVector2
	for i0 := range cNormals {
		p0 := *newVector2Ref(unsafe.Pointer(&cNormals[i0]))
		normals0[i0] = p0
	}
	obj.gNormals = normals0

	ret0, alloc0 := obj.passRef()
	ret1 := (*PolygonData)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *PolygonData) Index(index int32) *PolygonData {
	ptr1 := (*PolygonData)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfPolygonDataValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *PolygonData) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*PolygonData) {
			a.Free()
		})
	}
}

// Positions returns a reference to C object within a struct
func (x *PolygonData) Positionser(index int32) *Vector2 {
	var ret *Vector2

	ptr0 := &x.Positions
	ptr1 := (*C.Vector2)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfVector2Value)))
	ret = newVector2Ref(unsafe.Pointer(ptr1)).convert()

	return ret
}

// Normals returns a reference to C object within a struct
func (x *PolygonData) Normalser(index int32) *Vector2 {
	var ret *Vector2

	ptr0 := &x.Normals
	ptr1 := (*C.Vector2)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfVector2Value)))
	ret = newVector2Ref(unsafe.Pointer(ptr1)).convert()

	return ret
}

// allocPhysicsShapeMemory allocates memory for type C.PhysicsShape in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicsShapeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicsShapeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicsShapeValue = unsafe.Sizeof([1]C.PhysicsShape{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocStruct_PhysicsBodyDataMemory allocates memory for type C.struct_PhysicsBodyData in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct_PhysicsBodyDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct_PhysicsBodyDataValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStruct_PhysicsBodyDataValue = unsafe.Sizeof([1]C.struct_PhysicsBodyData{})

// unpackSPhysicsBodyData transforms a sliced Go data structure into plain C format.
func unpackSPhysicsBodyData(x []gPhysicsBodyData) (unpacked *C.struct_PhysicsBodyData, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_PhysicsBodyData) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStruct_PhysicsBodyDataMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_PhysicsBodyData)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].passValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_PhysicsBodyData)(h.Data)
	return
}

// newPhysicsShapeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newPhysicsShapeRef(ref unsafe.Pointer) *gPhysicsShape {
	if ref == nil {
		return nil
	}
	obj := new(gPhysicsShape)
	obj.ref4c540f1a = (*C.PhysicsShape)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gPhysicsShape) passRef() (*C.PhysicsShape, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4c540f1a != nil {
		if x.allocs4c540f1a != nil {
			return x.ref4c540f1a, x.allocs4c540f1a.(*cgoAllocMap)
		} else {
			return x.ref4c540f1a, nil
		}
	}
	mem4c540f1a := unsafe.Pointer(new(C.PhysicsShape))
	ref4c540f1a := (*C.PhysicsShape)(mem4c540f1a)
	allocs4c540f1a := new(cgoAllocMap)
	// allocs4c540f1a.Add(mem4c540f1a)

	var c_type_allocs *cgoAllocMap
	ref4c540f1a._type, c_type_allocs = (C.PhysicsShapeType)(x.gType), cgoAllocsUnknown
	allocs4c540f1a.Borrow(c_type_allocs)
	x.gType = *new(PhysicsShapeType)

	var cbody_allocs *cgoAllocMap
	ref4c540f1a.body, cbody_allocs = unpackSPhysicsBodyData(x.gBody)
	allocs4c540f1a.Borrow(cbody_allocs)
	x.gBody = *new([]gPhysicsBodyData)

	var cradius_allocs *cgoAllocMap
	ref4c540f1a.radius, cradius_allocs = (C.float)(x.gRadius), cgoAllocsUnknown
	allocs4c540f1a.Borrow(cradius_allocs)
	x.gRadius = *new(float32)

	var ctransform_allocs *cgoAllocMap
	ref4c540f1a.transform, ctransform_allocs = x.gTransform.passValue()
	allocs4c540f1a.Borrow(ctransform_allocs)
	x.gTransform = *new(gMatrix2x2)

	var cvertexData_allocs *cgoAllocMap
	ref4c540f1a.vertexData, cvertexData_allocs = x.gVertexData.passValue()
	allocs4c540f1a.Borrow(cvertexData_allocs)
	x.gVertexData = *new(gPolygonData)

	x.ref4c540f1a = ref4c540f1a
	x.allocs4c540f1a = allocs4c540f1a

	return ref4c540f1a, allocs4c540f1a
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gPhysicsShape) passValue() (C.PhysicsShape, *cgoAllocMap) {
	if x.ref4c540f1a != nil {
		return *x.ref4c540f1a, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gPhysicsShape) convert() *PhysicsShape {
	if x.ref4c540f1a != nil {
		return (*PhysicsShape)(unsafe.Pointer(x.ref4c540f1a))
	}
	x.passRef()
	return (*PhysicsShape)(unsafe.Pointer(x.ref4c540f1a))
}

// NewPhysicsShape new Go object and Mapping to C object.
func NewPhysicsShape(cType PhysicsShapeType, cBody []PhysicsBodyData, cRadius float32, cTransform Matrix2x2, cVertexData PolygonData) PhysicsShape {
	obj := *new(gPhysicsShape)
	obj.gType = cType

	var body0 []gPhysicsBodyData
	for i0 := range cBody {
		p0 := *newPhysicsBodyDataRef(unsafe.Pointer(&cBody[i0]))
		body0 = append(body0, p0)
	}
	obj.gBody = body0
	obj.gRadius = cRadius
	obj.gTransform = *newMatrix2x2Ref(unsafe.Pointer(&cTransform))
	obj.gVertexData = *newPolygonDataRef(unsafe.Pointer(&cVertexData))

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocPhysicsShape.")
	}
	return *(*PhysicsShape)(unsafe.Pointer(ret0))
}

// AllocPhysicsShape new Go object and Mapping to C object.
func AllocPhysicsShape(cType PhysicsShapeType, cBody []PhysicsBodyData, cRadius float32, cTransform Matrix2x2, cVertexData PolygonData) (*PhysicsShape, *cgoAllocMap) {
	obj := *new(gPhysicsShape)
	obj.gType = cType

	var body0 []gPhysicsBodyData
	for i0 := range cBody {
		p0 := *newPhysicsBodyDataRef(unsafe.Pointer(&cBody[i0]))
		body0 = append(body0, p0)
	}
	obj.gBody = body0
	obj.gRadius = cRadius
	obj.gTransform = *newMatrix2x2Ref(unsafe.Pointer(&cTransform))
	obj.gVertexData = *newPolygonDataRef(unsafe.Pointer(&cVertexData))

	ret0, alloc0 := obj.passRef()
	ret1 := (*PhysicsShape)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *PhysicsShape) Index(index int32) *PhysicsShape {
	ptr1 := (*PhysicsShape)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfPhysicsShapeValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *PhysicsShape) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*PhysicsShape) {
			a.Free()
		})
	}
}

// Body returns a reference to C object within a struct
func (x *PhysicsShape) Bodyer(index int32) *PhysicsBodyData {
	var ret *PhysicsBodyData

	ptr0 := x.Body
	ptr1 := (*C.struct_PhysicsBodyData)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfPhysicsBodyDataValue)))
	ret = newPhysicsBodyDataRef(unsafe.Pointer(ptr1)).convert()

	return ret
}

// allocPhysicsBodyDataMemory allocates memory for type C.PhysicsBodyData in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicsBodyDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicsBodyDataValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicsBodyDataValue = unsafe.Sizeof([1]C.PhysicsBodyData{})

// newPhysicsBodyDataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newPhysicsBodyDataRef(ref unsafe.Pointer) *gPhysicsBodyData {
	if ref == nil {
		return nil
	}
	obj := new(gPhysicsBodyData)
	obj.refd780e53 = (*C.PhysicsBodyData)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gPhysicsBodyData) passRef() (*C.PhysicsBodyData, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd780e53 != nil {
		if x.allocsd780e53 != nil {
			return x.refd780e53, x.allocsd780e53.(*cgoAllocMap)
		} else {
			return x.refd780e53, nil
		}
	}
	memd780e53 := unsafe.Pointer(new(C.PhysicsBodyData))
	refd780e53 := (*C.PhysicsBodyData)(memd780e53)
	allocsd780e53 := new(cgoAllocMap)
	// allocsd780e53.Add(memd780e53)

	var cid_allocs *cgoAllocMap
	refd780e53.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocsd780e53.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var cenabled_allocs *cgoAllocMap
	refd780e53.enabled, cenabled_allocs = (C._Bool)(x.gEnabled), cgoAllocsUnknown
	allocsd780e53.Borrow(cenabled_allocs)
	x.gEnabled = *new(bool)

	var cposition_allocs *cgoAllocMap
	refd780e53.position, cposition_allocs = x.gPosition.passValue()
	allocsd780e53.Borrow(cposition_allocs)
	x.gPosition = *new(gVector2)

	var cvelocity_allocs *cgoAllocMap
	refd780e53.velocity, cvelocity_allocs = x.gVelocity.passValue()
	allocsd780e53.Borrow(cvelocity_allocs)
	x.gVelocity = *new(gVector2)

	var cforce_allocs *cgoAllocMap
	refd780e53.force, cforce_allocs = x.gForce.passValue()
	allocsd780e53.Borrow(cforce_allocs)
	x.gForce = *new(gVector2)

	var cangularVelocity_allocs *cgoAllocMap
	refd780e53.angularVelocity, cangularVelocity_allocs = (C.float)(x.gAngularVelocity), cgoAllocsUnknown
	allocsd780e53.Borrow(cangularVelocity_allocs)
	x.gAngularVelocity = *new(float32)

	var ctorque_allocs *cgoAllocMap
	refd780e53.torque, ctorque_allocs = (C.float)(x.gTorque), cgoAllocsUnknown
	allocsd780e53.Borrow(ctorque_allocs)
	x.gTorque = *new(float32)

	var corient_allocs *cgoAllocMap
	refd780e53.orient, corient_allocs = (C.float)(x.gOrient), cgoAllocsUnknown
	allocsd780e53.Borrow(corient_allocs)
	x.gOrient = *new(float32)

	var cinertia_allocs *cgoAllocMap
	refd780e53.inertia, cinertia_allocs = (C.float)(x.gInertia), cgoAllocsUnknown
	allocsd780e53.Borrow(cinertia_allocs)
	x.gInertia = *new(float32)

	var cinverseInertia_allocs *cgoAllocMap
	refd780e53.inverseInertia, cinverseInertia_allocs = (C.float)(x.gInverseInertia), cgoAllocsUnknown
	allocsd780e53.Borrow(cinverseInertia_allocs)
	x.gInverseInertia = *new(float32)

	var cmass_allocs *cgoAllocMap
	refd780e53.mass, cmass_allocs = (C.float)(x.gMass), cgoAllocsUnknown
	allocsd780e53.Borrow(cmass_allocs)
	x.gMass = *new(float32)

	var cinverseMass_allocs *cgoAllocMap
	refd780e53.inverseMass, cinverseMass_allocs = (C.float)(x.gInverseMass), cgoAllocsUnknown
	allocsd780e53.Borrow(cinverseMass_allocs)
	x.gInverseMass = *new(float32)

	var cstaticFriction_allocs *cgoAllocMap
	refd780e53.staticFriction, cstaticFriction_allocs = (C.float)(x.gStaticFriction), cgoAllocsUnknown
	allocsd780e53.Borrow(cstaticFriction_allocs)
	x.gStaticFriction = *new(float32)

	var cdynamicFriction_allocs *cgoAllocMap
	refd780e53.dynamicFriction, cdynamicFriction_allocs = (C.float)(x.gDynamicFriction), cgoAllocsUnknown
	allocsd780e53.Borrow(cdynamicFriction_allocs)
	x.gDynamicFriction = *new(float32)

	var crestitution_allocs *cgoAllocMap
	refd780e53.restitution, crestitution_allocs = (C.float)(x.gRestitution), cgoAllocsUnknown
	allocsd780e53.Borrow(crestitution_allocs)
	x.gRestitution = *new(float32)

	var cuseGravity_allocs *cgoAllocMap
	refd780e53.useGravity, cuseGravity_allocs = (C._Bool)(x.gUseGravity), cgoAllocsUnknown
	allocsd780e53.Borrow(cuseGravity_allocs)
	x.gUseGravity = *new(bool)

	var cisGrounded_allocs *cgoAllocMap
	refd780e53.isGrounded, cisGrounded_allocs = (C._Bool)(x.gIsGrounded), cgoAllocsUnknown
	allocsd780e53.Borrow(cisGrounded_allocs)
	x.gIsGrounded = *new(bool)

	var cfreezeOrient_allocs *cgoAllocMap
	refd780e53.freezeOrient, cfreezeOrient_allocs = (C._Bool)(x.gFreezeOrient), cgoAllocsUnknown
	allocsd780e53.Borrow(cfreezeOrient_allocs)
	x.gFreezeOrient = *new(bool)

	var cshape_allocs *cgoAllocMap
	refd780e53.shape, cshape_allocs = x.gShape.passValue()
	allocsd780e53.Borrow(cshape_allocs)
	x.gShape = *new(gPhysicsShape)

	x.refd780e53 = refd780e53
	x.allocsd780e53 = allocsd780e53

	return refd780e53, allocsd780e53
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gPhysicsBodyData) passValue() (C.PhysicsBodyData, *cgoAllocMap) {
	if x.refd780e53 != nil {
		return *x.refd780e53, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gPhysicsBodyData) convert() *PhysicsBodyData {
	if x.refd780e53 != nil {
		return (*PhysicsBodyData)(unsafe.Pointer(x.refd780e53))
	}
	x.passRef()
	return (*PhysicsBodyData)(unsafe.Pointer(x.refd780e53))
}

// NewPhysicsBodyData new Go object and Mapping to C object.
func NewPhysicsBodyData(cId uint32, cEnabled bool, cPosition Vector2, cVelocity Vector2, cForce Vector2, cAngularVelocity float32, cTorque float32, cOrient float32, cInertia float32, cInverseInertia float32, cMass float32, cInverseMass float32, cStaticFriction float32, cDynamicFriction float32, cRestitution float32, cUseGravity bool, cIsGrounded bool, cFreezeOrient bool, cShape PhysicsShape) PhysicsBodyData {
	obj := *new(gPhysicsBodyData)
	obj.gId = cId
	obj.gEnabled = cEnabled
	obj.gPosition = *newVector2Ref(unsafe.Pointer(&cPosition))
	obj.gVelocity = *newVector2Ref(unsafe.Pointer(&cVelocity))
	obj.gForce = *newVector2Ref(unsafe.Pointer(&cForce))
	obj.gAngularVelocity = cAngularVelocity
	obj.gTorque = cTorque
	obj.gOrient = cOrient
	obj.gInertia = cInertia
	obj.gInverseInertia = cInverseInertia
	obj.gMass = cMass
	obj.gInverseMass = cInverseMass
	obj.gStaticFriction = cStaticFriction
	obj.gDynamicFriction = cDynamicFriction
	obj.gRestitution = cRestitution
	obj.gUseGravity = cUseGravity
	obj.gIsGrounded = cIsGrounded
	obj.gFreezeOrient = cFreezeOrient
	obj.gShape = *newPhysicsShapeRef(unsafe.Pointer(&cShape))

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocPhysicsBodyData.")
	}
	return *(*PhysicsBodyData)(unsafe.Pointer(ret0))
}

// AllocPhysicsBodyData new Go object and Mapping to C object.
func AllocPhysicsBodyData(cId uint32, cEnabled bool, cPosition Vector2, cVelocity Vector2, cForce Vector2, cAngularVelocity float32, cTorque float32, cOrient float32, cInertia float32, cInverseInertia float32, cMass float32, cInverseMass float32, cStaticFriction float32, cDynamicFriction float32, cRestitution float32, cUseGravity bool, cIsGrounded bool, cFreezeOrient bool, cShape PhysicsShape) (*PhysicsBodyData, *cgoAllocMap) {
	obj := *new(gPhysicsBodyData)
	obj.gId = cId
	obj.gEnabled = cEnabled
	obj.gPosition = *newVector2Ref(unsafe.Pointer(&cPosition))
	obj.gVelocity = *newVector2Ref(unsafe.Pointer(&cVelocity))
	obj.gForce = *newVector2Ref(unsafe.Pointer(&cForce))
	obj.gAngularVelocity = cAngularVelocity
	obj.gTorque = cTorque
	obj.gOrient = cOrient
	obj.gInertia = cInertia
	obj.gInverseInertia = cInverseInertia
	obj.gMass = cMass
	obj.gInverseMass = cInverseMass
	obj.gStaticFriction = cStaticFriction
	obj.gDynamicFriction = cDynamicFriction
	obj.gRestitution = cRestitution
	obj.gUseGravity = cUseGravity
	obj.gIsGrounded = cIsGrounded
	obj.gFreezeOrient = cFreezeOrient
	obj.gShape = *newPhysicsShapeRef(unsafe.Pointer(&cShape))

	ret0, alloc0 := obj.passRef()
	ret1 := (*PhysicsBodyData)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *PhysicsBodyData) Index(index int32) *PhysicsBodyData {
	ptr1 := (*PhysicsBodyData)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfPhysicsBodyDataValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *PhysicsBodyData) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*PhysicsBodyData) {
			a.Free()
		})
	}
}

// allocPhysicsManifoldDataMemory allocates memory for type C.PhysicsManifoldData in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicsManifoldDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicsManifoldDataValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicsManifoldDataValue = unsafe.Sizeof([1]C.PhysicsManifoldData{})

// allocA2Vector2Memory allocates memory for type [2]C.Vector2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA2Vector2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA2Vector2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA2Vector2Value = unsafe.Sizeof([1][2]C.Vector2{})

// unpackA2Vector2 transforms a sliced Go data structure into plain C format.
func unpackA2Vector2(x [2]gVector2) (unpacked [2]C.Vector2, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[2]C.Vector2) {
		go allocs.Free()
	})

	mem0 := allocA2Vector2Memory(1)
	allocs.Add(mem0)
	v0 := (*[2]C.Vector2)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].passValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[2]C.Vector2)(mem0)
	return
}

// newPhysicsManifoldDataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newPhysicsManifoldDataRef(ref unsafe.Pointer) *gPhysicsManifoldData {
	if ref == nil {
		return nil
	}
	obj := new(gPhysicsManifoldData)
	obj.ref10b92967 = (*C.PhysicsManifoldData)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gPhysicsManifoldData) passRef() (*C.PhysicsManifoldData, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref10b92967 != nil {
		if x.allocs10b92967 != nil {
			return x.ref10b92967, x.allocs10b92967.(*cgoAllocMap)
		} else {
			return x.ref10b92967, nil
		}
	}
	mem10b92967 := unsafe.Pointer(new(C.PhysicsManifoldData))
	ref10b92967 := (*C.PhysicsManifoldData)(mem10b92967)
	allocs10b92967 := new(cgoAllocMap)
	// allocs10b92967.Add(mem10b92967)

	var cid_allocs *cgoAllocMap
	ref10b92967.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs10b92967.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var cbodyA_allocs *cgoAllocMap
	ref10b92967.bodyA, cbodyA_allocs = unpackSPhysicsBodyData(x.gBodyA)
	allocs10b92967.Borrow(cbodyA_allocs)
	x.gBodyA = *new([]gPhysicsBodyData)

	var cbodyB_allocs *cgoAllocMap
	ref10b92967.bodyB, cbodyB_allocs = unpackSPhysicsBodyData(x.gBodyB)
	allocs10b92967.Borrow(cbodyB_allocs)
	x.gBodyB = *new([]gPhysicsBodyData)

	var cpenetration_allocs *cgoAllocMap
	ref10b92967.penetration, cpenetration_allocs = (C.float)(x.gPenetration), cgoAllocsUnknown
	allocs10b92967.Borrow(cpenetration_allocs)
	x.gPenetration = *new(float32)

	var cnormal_allocs *cgoAllocMap
	ref10b92967.normal, cnormal_allocs = x.gNormal.passValue()
	allocs10b92967.Borrow(cnormal_allocs)
	x.gNormal = *new(gVector2)

	var ccontacts_allocs *cgoAllocMap
	ref10b92967.contacts, ccontacts_allocs = unpackA2Vector2(x.gContacts)
	allocs10b92967.Borrow(ccontacts_allocs)
	x.gContacts = *new([2]gVector2)

	var ccontactsCount_allocs *cgoAllocMap
	ref10b92967.contactsCount, ccontactsCount_allocs = (C.uint)(x.gContactsCount), cgoAllocsUnknown
	allocs10b92967.Borrow(ccontactsCount_allocs)
	x.gContactsCount = *new(uint32)

	var crestitution_allocs *cgoAllocMap
	ref10b92967.restitution, crestitution_allocs = (C.float)(x.gRestitution), cgoAllocsUnknown
	allocs10b92967.Borrow(crestitution_allocs)
	x.gRestitution = *new(float32)

	var cdynamicFriction_allocs *cgoAllocMap
	ref10b92967.dynamicFriction, cdynamicFriction_allocs = (C.float)(x.gDynamicFriction), cgoAllocsUnknown
	allocs10b92967.Borrow(cdynamicFriction_allocs)
	x.gDynamicFriction = *new(float32)

	var cstaticFriction_allocs *cgoAllocMap
	ref10b92967.staticFriction, cstaticFriction_allocs = (C.float)(x.gStaticFriction), cgoAllocsUnknown
	allocs10b92967.Borrow(cstaticFriction_allocs)
	x.gStaticFriction = *new(float32)

	x.ref10b92967 = ref10b92967
	x.allocs10b92967 = allocs10b92967

	return ref10b92967, allocs10b92967
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gPhysicsManifoldData) passValue() (C.PhysicsManifoldData, *cgoAllocMap) {
	if x.ref10b92967 != nil {
		return *x.ref10b92967, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gPhysicsManifoldData) convert() *PhysicsManifoldData {
	if x.ref10b92967 != nil {
		return (*PhysicsManifoldData)(unsafe.Pointer(x.ref10b92967))
	}
	x.passRef()
	return (*PhysicsManifoldData)(unsafe.Pointer(x.ref10b92967))
}

// NewPhysicsManifoldData new Go object and Mapping to C object.
func NewPhysicsManifoldData(cId uint32, cBodyA []PhysicsBodyData, cBodyB []PhysicsBodyData, cPenetration float32, cNormal Vector2, cContacts [2]Vector2, cContactsCount uint32, cRestitution float32, cDynamicFriction float32, cStaticFriction float32) PhysicsManifoldData {
	obj := *new(gPhysicsManifoldData)
	obj.gId = cId

	var bodyA0 []gPhysicsBodyData
	for i0 := range cBodyA {
		p0 := *newPhysicsBodyDataRef(unsafe.Pointer(&cBodyA[i0]))
		bodyA0 = append(bodyA0, p0)
	}
	obj.gBodyA = bodyA0

	var bodyB0 []gPhysicsBodyData
	for i0 := range cBodyB {
		p0 := *newPhysicsBodyDataRef(unsafe.Pointer(&cBodyB[i0]))
		bodyB0 = append(bodyB0, p0)
	}
	obj.gBodyB = bodyB0
	obj.gPenetration = cPenetration
	obj.gNormal = *newVector2Ref(unsafe.Pointer(&cNormal))

	var contacts0 [2]gVector2
	for i0 := range cContacts {
		p0 := *newVector2Ref(unsafe.Pointer(&cContacts[i0]))
		contacts0[i0] = p0
	}
	obj.gContacts = contacts0
	obj.gContactsCount = cContactsCount
	obj.gRestitution = cRestitution
	obj.gDynamicFriction = cDynamicFriction
	obj.gStaticFriction = cStaticFriction

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocPhysicsManifoldData.")
	}
	return *(*PhysicsManifoldData)(unsafe.Pointer(ret0))
}

// AllocPhysicsManifoldData new Go object and Mapping to C object.
func AllocPhysicsManifoldData(cId uint32, cBodyA []PhysicsBodyData, cBodyB []PhysicsBodyData, cPenetration float32, cNormal Vector2, cContacts [2]Vector2, cContactsCount uint32, cRestitution float32, cDynamicFriction float32, cStaticFriction float32) (*PhysicsManifoldData, *cgoAllocMap) {
	obj := *new(gPhysicsManifoldData)
	obj.gId = cId

	var bodyA0 []gPhysicsBodyData
	for i0 := range cBodyA {
		p0 := *newPhysicsBodyDataRef(unsafe.Pointer(&cBodyA[i0]))
		bodyA0 = append(bodyA0, p0)
	}
	obj.gBodyA = bodyA0

	var bodyB0 []gPhysicsBodyData
	for i0 := range cBodyB {
		p0 := *newPhysicsBodyDataRef(unsafe.Pointer(&cBodyB[i0]))
		bodyB0 = append(bodyB0, p0)
	}
	obj.gBodyB = bodyB0
	obj.gPenetration = cPenetration
	obj.gNormal = *newVector2Ref(unsafe.Pointer(&cNormal))

	var contacts0 [2]gVector2
	for i0 := range cContacts {
		p0 := *newVector2Ref(unsafe.Pointer(&cContacts[i0]))
		contacts0[i0] = p0
	}
	obj.gContacts = contacts0
	obj.gContactsCount = cContactsCount
	obj.gRestitution = cRestitution
	obj.gDynamicFriction = cDynamicFriction
	obj.gStaticFriction = cStaticFriction

	ret0, alloc0 := obj.passRef()
	ret1 := (*PhysicsManifoldData)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *PhysicsManifoldData) Index(index int32) *PhysicsManifoldData {
	ptr1 := (*PhysicsManifoldData)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfPhysicsManifoldDataValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *PhysicsManifoldData) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*PhysicsManifoldData) {
			a.Free()
		})
	}
}

// BodyA returns a reference to C object within a struct
func (x *PhysicsManifoldData) BodyAer(index int32) *PhysicsBodyData {
	var ret *PhysicsBodyData

	ptr0 := x.BodyA
	ptr1 := (*C.struct_PhysicsBodyData)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfPhysicsBodyDataValue)))
	ret = newPhysicsBodyDataRef(unsafe.Pointer(ptr1)).convert()

	return ret
}

// BodyB returns a reference to C object within a struct
func (x *PhysicsManifoldData) BodyBer(index int32) *PhysicsBodyData {
	var ret *PhysicsBodyData

	ptr0 := x.BodyB
	ptr1 := (*C.struct_PhysicsBodyData)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfPhysicsBodyDataValue)))
	ret = newPhysicsBodyDataRef(unsafe.Pointer(ptr1)).convert()

	return ret
}

// Contacts returns a reference to C object within a struct
func (x *PhysicsManifoldData) Contactser(index int32) *Vector2 {
	var ret *Vector2

	ptr0 := &x.Contacts
	ptr1 := (*C.Vector2)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfVector2Value)))
	ret = newVector2Ref(unsafe.Pointer(ptr1)).convert()

	return ret
}
