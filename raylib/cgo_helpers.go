// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Wed, 13 Jan 2021 11:57:32 CST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package raylib

/*
#include "../lib/raylib/src/raylib.h"
#include "../lib/raylib/src/raymath.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)
var allocReferenceCount int

func init() {
	allocReferenceCount = 0
}

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	defer a.mux.Unlock()

	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}

	allocReferenceCount++
	fmt.Printf("INFO: MEMORY: [PTR %p] CGO memory alloc\n", ptr)
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	defer a.mux.RUnlock()

	isEmpty := len(a.m) == 0
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}

	b.mux.Lock()
	defer b.mux.Unlock()
	a.mux.Lock()
	defer a.mux.Unlock()

	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	defer a.mux.Unlock()

	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)

		allocReferenceCount--
		fmt.Printf("INFO: MEMORY: [PTR %p] CGO memory free\n", ptr)
	}
}

// allocVector2Memory allocates memory for type C.Vector2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector2Value = unsafe.Sizeof([1]C.Vector2{})

// newVector2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newVector2Ref(ref unsafe.Pointer) *gVector2 {
	if ref == nil {
		return nil
	}
	obj := new(gVector2)
	obj.ref29ca61a5 = (*C.Vector2)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gVector2) passRef() (*C.Vector2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref29ca61a5 != nil {
		if x.allocs29ca61a5 != nil {
			return x.ref29ca61a5, x.allocs29ca61a5.(*cgoAllocMap)
		} else {
			return x.ref29ca61a5, nil
		}
	}
	mem29ca61a5 := unsafe.Pointer(new(C.Vector2))
	ref29ca61a5 := (*C.Vector2)(mem29ca61a5)
	allocs29ca61a5 := new(cgoAllocMap)
	// allocs29ca61a5.Add(mem29ca61a5)

	var cx_allocs *cgoAllocMap
	ref29ca61a5.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	ref29ca61a5.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cy_allocs)
	x.gY = *new(float32)

	x.ref29ca61a5 = ref29ca61a5
	x.allocs29ca61a5 = allocs29ca61a5

	return ref29ca61a5, allocs29ca61a5
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gVector2) passValue() (C.Vector2, *cgoAllocMap) {
	if x.ref29ca61a5 != nil {
		return *x.ref29ca61a5, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gVector2) convert() *Vector2 {
	if x.ref29ca61a5 != nil {
		return (*Vector2)(unsafe.Pointer(x.ref29ca61a5))
	}
	x.passRef()
	return (*Vector2)(unsafe.Pointer(x.ref29ca61a5))
}

// NewVector2 new Go object and Mapping to C object.
func NewVector2(cX float32, cY float32) Vector2 {
	obj := *new(gVector2)
	obj.gX = cX
	obj.gY = cY

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocVector2.")
	}
	return *(*Vector2)(unsafe.Pointer(ret0))
}

// AllocVector2 new Go object and Mapping to C object.
func AllocVector2(cX float32, cY float32) (*Vector2, *cgoAllocMap) {
	obj := *new(gVector2)
	obj.gX = cX
	obj.gY = cY

	ret0, alloc0 := obj.passRef()
	ret1 := (*Vector2)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Vector2) Index(index int32) *Vector2 {
	ptr1 := (*Vector2)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfVector2Value)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Vector2) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Vector2) {
			a.Free()
		})
	}
}

// allocVector3Memory allocates memory for type C.Vector3 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector3Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector3Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector3Value = unsafe.Sizeof([1]C.Vector3{})

// newVector3Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newVector3Ref(ref unsafe.Pointer) *gVector3 {
	if ref == nil {
		return nil
	}
	obj := new(gVector3)
	obj.ref5ecd5133 = (*C.Vector3)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gVector3) passRef() (*C.Vector3, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ecd5133 != nil {
		if x.allocs5ecd5133 != nil {
			return x.ref5ecd5133, x.allocs5ecd5133.(*cgoAllocMap)
		} else {
			return x.ref5ecd5133, nil
		}
	}
	mem5ecd5133 := unsafe.Pointer(new(C.Vector3))
	ref5ecd5133 := (*C.Vector3)(mem5ecd5133)
	allocs5ecd5133 := new(cgoAllocMap)
	// allocs5ecd5133.Add(mem5ecd5133)

	var cx_allocs *cgoAllocMap
	ref5ecd5133.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	ref5ecd5133.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cy_allocs)
	x.gY = *new(float32)

	var cz_allocs *cgoAllocMap
	ref5ecd5133.z, cz_allocs = (C.float)(x.gZ), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cz_allocs)
	x.gZ = *new(float32)

	x.ref5ecd5133 = ref5ecd5133
	x.allocs5ecd5133 = allocs5ecd5133

	return ref5ecd5133, allocs5ecd5133
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gVector3) passValue() (C.Vector3, *cgoAllocMap) {
	if x.ref5ecd5133 != nil {
		return *x.ref5ecd5133, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gVector3) convert() *Vector3 {
	if x.ref5ecd5133 != nil {
		return (*Vector3)(unsafe.Pointer(x.ref5ecd5133))
	}
	x.passRef()
	return (*Vector3)(unsafe.Pointer(x.ref5ecd5133))
}

// NewVector3 new Go object and Mapping to C object.
func NewVector3(cX float32, cY float32, cZ float32) Vector3 {
	obj := *new(gVector3)
	obj.gX = cX
	obj.gY = cY
	obj.gZ = cZ

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocVector3.")
	}
	return *(*Vector3)(unsafe.Pointer(ret0))
}

// AllocVector3 new Go object and Mapping to C object.
func AllocVector3(cX float32, cY float32, cZ float32) (*Vector3, *cgoAllocMap) {
	obj := *new(gVector3)
	obj.gX = cX
	obj.gY = cY
	obj.gZ = cZ

	ret0, alloc0 := obj.passRef()
	ret1 := (*Vector3)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Vector3) Index(index int32) *Vector3 {
	ptr1 := (*Vector3)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfVector3Value)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Vector3) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Vector3) {
			a.Free()
		})
	}
}

// allocVector4Memory allocates memory for type C.Vector4 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector4Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector4Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector4Value = unsafe.Sizeof([1]C.Vector4{})

// newVector4Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newVector4Ref(ref unsafe.Pointer) *gVector4 {
	if ref == nil {
		return nil
	}
	obj := new(gVector4)
	obj.refc0a9c490 = (*C.Vector4)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gVector4) passRef() (*C.Vector4, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0a9c490 != nil {
		if x.allocsc0a9c490 != nil {
			return x.refc0a9c490, x.allocsc0a9c490.(*cgoAllocMap)
		} else {
			return x.refc0a9c490, nil
		}
	}
	memc0a9c490 := unsafe.Pointer(new(C.Vector4))
	refc0a9c490 := (*C.Vector4)(memc0a9c490)
	allocsc0a9c490 := new(cgoAllocMap)
	// allocsc0a9c490.Add(memc0a9c490)

	var cx_allocs *cgoAllocMap
	refc0a9c490.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	refc0a9c490.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cy_allocs)
	x.gY = *new(float32)

	var cz_allocs *cgoAllocMap
	refc0a9c490.z, cz_allocs = (C.float)(x.gZ), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cz_allocs)
	x.gZ = *new(float32)

	var cw_allocs *cgoAllocMap
	refc0a9c490.w, cw_allocs = (C.float)(x.gW), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cw_allocs)
	x.gW = *new(float32)

	x.refc0a9c490 = refc0a9c490
	x.allocsc0a9c490 = allocsc0a9c490

	return refc0a9c490, allocsc0a9c490
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gVector4) passValue() (C.Vector4, *cgoAllocMap) {
	if x.refc0a9c490 != nil {
		return *x.refc0a9c490, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gVector4) convert() *Vector4 {
	if x.refc0a9c490 != nil {
		return (*Vector4)(unsafe.Pointer(x.refc0a9c490))
	}
	x.passRef()
	return (*Vector4)(unsafe.Pointer(x.refc0a9c490))
}

// NewVector4 new Go object and Mapping to C object.
func NewVector4(cX float32, cY float32, cZ float32, cW float32) Vector4 {
	obj := *new(gVector4)
	obj.gX = cX
	obj.gY = cY
	obj.gZ = cZ
	obj.gW = cW

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocVector4.")
	}
	return *(*Vector4)(unsafe.Pointer(ret0))
}

// AllocVector4 new Go object and Mapping to C object.
func AllocVector4(cX float32, cY float32, cZ float32, cW float32) (*Vector4, *cgoAllocMap) {
	obj := *new(gVector4)
	obj.gX = cX
	obj.gY = cY
	obj.gZ = cZ
	obj.gW = cW

	ret0, alloc0 := obj.passRef()
	ret1 := (*Vector4)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Vector4) Index(index int32) *Vector4 {
	ptr1 := (*Vector4)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfVector4Value)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Vector4) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Vector4) {
			a.Free()
		})
	}
}

// newQuaternionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newQuaternionRef(ref unsafe.Pointer) *gQuaternion {
	if ref == nil {
		return nil
	}
	obj := new(gQuaternion)
	obj.refc0a9c490 = (*C.Vector4)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gQuaternion) passRef() (*C.Vector4, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0a9c490 != nil {
		if x.allocsc0a9c490 != nil {
			return x.refc0a9c490, x.allocsc0a9c490.(*cgoAllocMap)
		} else {
			return x.refc0a9c490, nil
		}
	}
	memc0a9c490 := unsafe.Pointer(new(C.Vector4))
	refc0a9c490 := (*C.Vector4)(memc0a9c490)
	allocsc0a9c490 := new(cgoAllocMap)
	// allocsc0a9c490.Add(memc0a9c490)

	var cx_allocs *cgoAllocMap
	refc0a9c490.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	refc0a9c490.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cy_allocs)
	x.gY = *new(float32)

	var cz_allocs *cgoAllocMap
	refc0a9c490.z, cz_allocs = (C.float)(x.gZ), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cz_allocs)
	x.gZ = *new(float32)

	var cw_allocs *cgoAllocMap
	refc0a9c490.w, cw_allocs = (C.float)(x.gW), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cw_allocs)
	x.gW = *new(float32)

	x.refc0a9c490 = refc0a9c490
	x.allocsc0a9c490 = allocsc0a9c490

	return refc0a9c490, allocsc0a9c490
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gQuaternion) passValue() (C.Vector4, *cgoAllocMap) {
	if x.refc0a9c490 != nil {
		return *x.refc0a9c490, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gQuaternion) convert() *Quaternion {
	if x.refc0a9c490 != nil {
		return (*Quaternion)(unsafe.Pointer(x.refc0a9c490))
	}
	x.passRef()
	return (*Quaternion)(unsafe.Pointer(x.refc0a9c490))
}

// NewQuaternion new Go object and Mapping to C object.
func NewQuaternion(cX float32, cY float32, cZ float32, cW float32) Quaternion {
	obj := *new(gQuaternion)
	obj.gX = cX
	obj.gY = cY
	obj.gZ = cZ
	obj.gW = cW

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocQuaternion.")
	}
	return *(*Quaternion)(unsafe.Pointer(ret0))
}

// AllocQuaternion new Go object and Mapping to C object.
func AllocQuaternion(cX float32, cY float32, cZ float32, cW float32) (*Quaternion, *cgoAllocMap) {
	obj := *new(gQuaternion)
	obj.gX = cX
	obj.gY = cY
	obj.gZ = cZ
	obj.gW = cW

	ret0, alloc0 := obj.passRef()
	ret1 := (*Quaternion)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Quaternion) Index(index int32) *Quaternion {
	ptr1 := (*Quaternion)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfVector4Value)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Quaternion) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Quaternion) {
			a.Free()
		})
	}
}

// allocMatrixMemory allocates memory for type C.Matrix in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMatrixMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMatrixValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMatrixValue = unsafe.Sizeof([1]C.Matrix{})

// newMatrixRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newMatrixRef(ref unsafe.Pointer) *gMatrix {
	if ref == nil {
		return nil
	}
	obj := new(gMatrix)
	obj.refff9f44f9 = (*C.Matrix)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gMatrix) passRef() (*C.Matrix, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refff9f44f9 != nil {
		if x.allocsff9f44f9 != nil {
			return x.refff9f44f9, x.allocsff9f44f9.(*cgoAllocMap)
		} else {
			return x.refff9f44f9, nil
		}
	}
	memff9f44f9 := unsafe.Pointer(new(C.Matrix))
	refff9f44f9 := (*C.Matrix)(memff9f44f9)
	allocsff9f44f9 := new(cgoAllocMap)
	// allocsff9f44f9.Add(memff9f44f9)

	var cm0_allocs *cgoAllocMap
	refff9f44f9.m0, cm0_allocs = (C.float)(x.gM0), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm0_allocs)
	x.gM0 = *new(float32)

	var cm4_allocs *cgoAllocMap
	refff9f44f9.m4, cm4_allocs = (C.float)(x.gM4), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm4_allocs)
	x.gM4 = *new(float32)

	var cm8_allocs *cgoAllocMap
	refff9f44f9.m8, cm8_allocs = (C.float)(x.gM8), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm8_allocs)
	x.gM8 = *new(float32)

	var cm12_allocs *cgoAllocMap
	refff9f44f9.m12, cm12_allocs = (C.float)(x.gM12), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm12_allocs)
	x.gM12 = *new(float32)

	var cm1_allocs *cgoAllocMap
	refff9f44f9.m1, cm1_allocs = (C.float)(x.gM1), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm1_allocs)
	x.gM1 = *new(float32)

	var cm5_allocs *cgoAllocMap
	refff9f44f9.m5, cm5_allocs = (C.float)(x.gM5), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm5_allocs)
	x.gM5 = *new(float32)

	var cm9_allocs *cgoAllocMap
	refff9f44f9.m9, cm9_allocs = (C.float)(x.gM9), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm9_allocs)
	x.gM9 = *new(float32)

	var cm13_allocs *cgoAllocMap
	refff9f44f9.m13, cm13_allocs = (C.float)(x.gM13), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm13_allocs)
	x.gM13 = *new(float32)

	var cm2_allocs *cgoAllocMap
	refff9f44f9.m2, cm2_allocs = (C.float)(x.gM2), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm2_allocs)
	x.gM2 = *new(float32)

	var cm6_allocs *cgoAllocMap
	refff9f44f9.m6, cm6_allocs = (C.float)(x.gM6), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm6_allocs)
	x.gM6 = *new(float32)

	var cm10_allocs *cgoAllocMap
	refff9f44f9.m10, cm10_allocs = (C.float)(x.gM10), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm10_allocs)
	x.gM10 = *new(float32)

	var cm14_allocs *cgoAllocMap
	refff9f44f9.m14, cm14_allocs = (C.float)(x.gM14), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm14_allocs)
	x.gM14 = *new(float32)

	var cm3_allocs *cgoAllocMap
	refff9f44f9.m3, cm3_allocs = (C.float)(x.gM3), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm3_allocs)
	x.gM3 = *new(float32)

	var cm7_allocs *cgoAllocMap
	refff9f44f9.m7, cm7_allocs = (C.float)(x.gM7), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm7_allocs)
	x.gM7 = *new(float32)

	var cm11_allocs *cgoAllocMap
	refff9f44f9.m11, cm11_allocs = (C.float)(x.gM11), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm11_allocs)
	x.gM11 = *new(float32)

	var cm15_allocs *cgoAllocMap
	refff9f44f9.m15, cm15_allocs = (C.float)(x.gM15), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm15_allocs)
	x.gM15 = *new(float32)

	x.refff9f44f9 = refff9f44f9
	x.allocsff9f44f9 = allocsff9f44f9

	return refff9f44f9, allocsff9f44f9
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gMatrix) passValue() (C.Matrix, *cgoAllocMap) {
	if x.refff9f44f9 != nil {
		return *x.refff9f44f9, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gMatrix) convert() *Matrix {
	if x.refff9f44f9 != nil {
		return (*Matrix)(unsafe.Pointer(x.refff9f44f9))
	}
	x.passRef()
	return (*Matrix)(unsafe.Pointer(x.refff9f44f9))
}

// NewMatrix new Go object and Mapping to C object.
func NewMatrix(cM0 float32, cM4 float32, cM8 float32, cM12 float32, cM1 float32, cM5 float32, cM9 float32, cM13 float32, cM2 float32, cM6 float32, cM10 float32, cM14 float32, cM3 float32, cM7 float32, cM11 float32, cM15 float32) Matrix {
	obj := *new(gMatrix)
	obj.gM0 = cM0
	obj.gM4 = cM4
	obj.gM8 = cM8
	obj.gM12 = cM12
	obj.gM1 = cM1
	obj.gM5 = cM5
	obj.gM9 = cM9
	obj.gM13 = cM13
	obj.gM2 = cM2
	obj.gM6 = cM6
	obj.gM10 = cM10
	obj.gM14 = cM14
	obj.gM3 = cM3
	obj.gM7 = cM7
	obj.gM11 = cM11
	obj.gM15 = cM15

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocMatrix.")
	}
	return *(*Matrix)(unsafe.Pointer(ret0))
}

// AllocMatrix new Go object and Mapping to C object.
func AllocMatrix(cM0 float32, cM4 float32, cM8 float32, cM12 float32, cM1 float32, cM5 float32, cM9 float32, cM13 float32, cM2 float32, cM6 float32, cM10 float32, cM14 float32, cM3 float32, cM7 float32, cM11 float32, cM15 float32) (*Matrix, *cgoAllocMap) {
	obj := *new(gMatrix)
	obj.gM0 = cM0
	obj.gM4 = cM4
	obj.gM8 = cM8
	obj.gM12 = cM12
	obj.gM1 = cM1
	obj.gM5 = cM5
	obj.gM9 = cM9
	obj.gM13 = cM13
	obj.gM2 = cM2
	obj.gM6 = cM6
	obj.gM10 = cM10
	obj.gM14 = cM14
	obj.gM3 = cM3
	obj.gM7 = cM7
	obj.gM11 = cM11
	obj.gM15 = cM15

	ret0, alloc0 := obj.passRef()
	ret1 := (*Matrix)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Matrix) Index(index int32) *Matrix {
	ptr1 := (*Matrix)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfMatrixValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Matrix) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Matrix) {
			a.Free()
		})
	}
}

// allocColorMemory allocates memory for type C.Color in C.
// The caller is responsible for freeing the this memory via C.free.
func allocColorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfColorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfColorValue = unsafe.Sizeof([1]C.Color{})

// newColorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newColorRef(ref unsafe.Pointer) *gColor {
	if ref == nil {
		return nil
	}
	obj := new(gColor)
	obj.refa79767ed = (*C.Color)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gColor) passRef() (*C.Color, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa79767ed != nil {
		if x.allocsa79767ed != nil {
			return x.refa79767ed, x.allocsa79767ed.(*cgoAllocMap)
		} else {
			return x.refa79767ed, nil
		}
	}
	mema79767ed := unsafe.Pointer(new(C.Color))
	refa79767ed := (*C.Color)(mema79767ed)
	allocsa79767ed := new(cgoAllocMap)
	// allocsa79767ed.Add(mema79767ed)

	var cr_allocs *cgoAllocMap
	refa79767ed.r, cr_allocs = (C.uchar)(x.gR), cgoAllocsUnknown
	allocsa79767ed.Borrow(cr_allocs)
	x.gR = *new(byte)

	var cg_allocs *cgoAllocMap
	refa79767ed.g, cg_allocs = (C.uchar)(x.gG), cgoAllocsUnknown
	allocsa79767ed.Borrow(cg_allocs)
	x.gG = *new(byte)

	var cb_allocs *cgoAllocMap
	refa79767ed.b, cb_allocs = (C.uchar)(x.gB), cgoAllocsUnknown
	allocsa79767ed.Borrow(cb_allocs)
	x.gB = *new(byte)

	var ca_allocs *cgoAllocMap
	refa79767ed.a, ca_allocs = (C.uchar)(x.gA), cgoAllocsUnknown
	allocsa79767ed.Borrow(ca_allocs)
	x.gA = *new(byte)

	x.refa79767ed = refa79767ed
	x.allocsa79767ed = allocsa79767ed

	return refa79767ed, allocsa79767ed
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gColor) passValue() (C.Color, *cgoAllocMap) {
	if x.refa79767ed != nil {
		return *x.refa79767ed, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gColor) convert() *Color {
	if x.refa79767ed != nil {
		return (*Color)(unsafe.Pointer(x.refa79767ed))
	}
	x.passRef()
	return (*Color)(unsafe.Pointer(x.refa79767ed))
}

// NewColor new Go object and Mapping to C object.
func NewColor(cR byte, cG byte, cB byte, cA byte) Color {
	obj := *new(gColor)
	obj.gR = cR
	obj.gG = cG
	obj.gB = cB
	obj.gA = cA

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocColor.")
	}
	return *(*Color)(unsafe.Pointer(ret0))
}

// AllocColor new Go object and Mapping to C object.
func AllocColor(cR byte, cG byte, cB byte, cA byte) (*Color, *cgoAllocMap) {
	obj := *new(gColor)
	obj.gR = cR
	obj.gG = cG
	obj.gB = cB
	obj.gA = cA

	ret0, alloc0 := obj.passRef()
	ret1 := (*Color)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Color) Index(index int32) *Color {
	ptr1 := (*Color)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfColorValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Color) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Color) {
			a.Free()
		})
	}
}

// allocRectangleMemory allocates memory for type C.Rectangle in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRectangleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRectangleValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRectangleValue = unsafe.Sizeof([1]C.Rectangle{})

// newRectangleRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newRectangleRef(ref unsafe.Pointer) *gRectangle {
	if ref == nil {
		return nil
	}
	obj := new(gRectangle)
	obj.refcee8783a = (*C.Rectangle)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gRectangle) passRef() (*C.Rectangle, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcee8783a != nil {
		if x.allocscee8783a != nil {
			return x.refcee8783a, x.allocscee8783a.(*cgoAllocMap)
		} else {
			return x.refcee8783a, nil
		}
	}
	memcee8783a := unsafe.Pointer(new(C.Rectangle))
	refcee8783a := (*C.Rectangle)(memcee8783a)
	allocscee8783a := new(cgoAllocMap)
	// allocscee8783a.Add(memcee8783a)

	var cx_allocs *cgoAllocMap
	refcee8783a.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocscee8783a.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	refcee8783a.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocscee8783a.Borrow(cy_allocs)
	x.gY = *new(float32)

	var cwidth_allocs *cgoAllocMap
	refcee8783a.width, cwidth_allocs = (C.float)(x.gWidth), cgoAllocsUnknown
	allocscee8783a.Borrow(cwidth_allocs)
	x.gWidth = *new(float32)

	var cheight_allocs *cgoAllocMap
	refcee8783a.height, cheight_allocs = (C.float)(x.gHeight), cgoAllocsUnknown
	allocscee8783a.Borrow(cheight_allocs)
	x.gHeight = *new(float32)

	x.refcee8783a = refcee8783a
	x.allocscee8783a = allocscee8783a

	return refcee8783a, allocscee8783a
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gRectangle) passValue() (C.Rectangle, *cgoAllocMap) {
	if x.refcee8783a != nil {
		return *x.refcee8783a, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gRectangle) convert() *Rectangle {
	if x.refcee8783a != nil {
		return (*Rectangle)(unsafe.Pointer(x.refcee8783a))
	}
	x.passRef()
	return (*Rectangle)(unsafe.Pointer(x.refcee8783a))
}

// NewRectangle new Go object and Mapping to C object.
func NewRectangle(cX float32, cY float32, cWidth float32, cHeight float32) Rectangle {
	obj := *new(gRectangle)
	obj.gX = cX
	obj.gY = cY
	obj.gWidth = cWidth
	obj.gHeight = cHeight

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocRectangle.")
	}
	return *(*Rectangle)(unsafe.Pointer(ret0))
}

// AllocRectangle new Go object and Mapping to C object.
func AllocRectangle(cX float32, cY float32, cWidth float32, cHeight float32) (*Rectangle, *cgoAllocMap) {
	obj := *new(gRectangle)
	obj.gX = cX
	obj.gY = cY
	obj.gWidth = cWidth
	obj.gHeight = cHeight

	ret0, alloc0 := obj.passRef()
	ret1 := (*Rectangle)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Rectangle) Index(index int32) *Rectangle {
	ptr1 := (*Rectangle)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfRectangleValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Rectangle) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Rectangle) {
			a.Free()
		})
	}
}

// allocImageMemory allocates memory for type C.Image in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageValue = unsafe.Sizeof([1]C.Image{})

// newImageRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newImageRef(ref unsafe.Pointer) *gImage {
	if ref == nil {
		return nil
	}
	obj := new(gImage)
	obj.ref4fc2b5b = (*C.Image)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gImage) passRef() (*C.Image, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4fc2b5b != nil {
		if x.allocs4fc2b5b != nil {
			return x.ref4fc2b5b, x.allocs4fc2b5b.(*cgoAllocMap)
		} else {
			return x.ref4fc2b5b, nil
		}
	}
	mem4fc2b5b := unsafe.Pointer(new(C.Image))
	ref4fc2b5b := (*C.Image)(mem4fc2b5b)
	allocs4fc2b5b := new(cgoAllocMap)
	// allocs4fc2b5b.Add(mem4fc2b5b)

	var cdata_allocs *cgoAllocMap
	ref4fc2b5b.data, cdata_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.gData)), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cdata_allocs)
	x.gData = *new(unsafe.Pointer)

	var cwidth_allocs *cgoAllocMap
	ref4fc2b5b.width, cwidth_allocs = (C.int)(x.gWidth), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cwidth_allocs)
	x.gWidth = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref4fc2b5b.height, cheight_allocs = (C.int)(x.gHeight), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cheight_allocs)
	x.gHeight = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref4fc2b5b.mipmaps, cmipmaps_allocs = (C.int)(x.gMipmaps), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cmipmaps_allocs)
	x.gMipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref4fc2b5b.format, cformat_allocs = (C.int)(x.gFormat), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cformat_allocs)
	x.gFormat = *new(int32)

	x.ref4fc2b5b = ref4fc2b5b
	x.allocs4fc2b5b = allocs4fc2b5b

	return ref4fc2b5b, allocs4fc2b5b
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gImage) passValue() (C.Image, *cgoAllocMap) {
	if x.ref4fc2b5b != nil {
		return *x.ref4fc2b5b, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gImage) convert() *Image {
	if x.ref4fc2b5b != nil {
		return (*Image)(unsafe.Pointer(x.ref4fc2b5b))
	}
	x.passRef()
	return (*Image)(unsafe.Pointer(x.ref4fc2b5b))
}

// NewImage new Go object and Mapping to C object.
func NewImage(cData unsafe.Pointer, cWidth int32, cHeight int32, cMipmaps int32, cFormat int32) Image {
	obj := *new(gImage)
	obj.gData = cData
	obj.gWidth = cWidth
	obj.gHeight = cHeight
	obj.gMipmaps = cMipmaps
	obj.gFormat = cFormat

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocImage.")
	}
	return *(*Image)(unsafe.Pointer(ret0))
}

// AllocImage new Go object and Mapping to C object.
func AllocImage(cData unsafe.Pointer, cWidth int32, cHeight int32, cMipmaps int32, cFormat int32) (*Image, *cgoAllocMap) {
	obj := *new(gImage)
	obj.gData = cData
	obj.gWidth = cWidth
	obj.gHeight = cHeight
	obj.gMipmaps = cMipmaps
	obj.gFormat = cFormat

	ret0, alloc0 := obj.passRef()
	ret1 := (*Image)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Image) Index(index int32) *Image {
	ptr1 := (*Image)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfImageValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Image) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Image) {
			a.Free()
		})
	}
}

// allocTextureMemory allocates memory for type C.Texture in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTextureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTextureValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTextureValue = unsafe.Sizeof([1]C.Texture{})

// newTextureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newTextureRef(ref unsafe.Pointer) *gTexture {
	if ref == nil {
		return nil
	}
	obj := new(gTexture)
	obj.ref4ddb34ee = (*C.Texture)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gTexture) passRef() (*C.Texture, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4ddb34ee != nil {
		if x.allocs4ddb34ee != nil {
			return x.ref4ddb34ee, x.allocs4ddb34ee.(*cgoAllocMap)
		} else {
			return x.ref4ddb34ee, nil
		}
	}
	mem4ddb34ee := unsafe.Pointer(new(C.Texture))
	ref4ddb34ee := (*C.Texture)(mem4ddb34ee)
	allocs4ddb34ee := new(cgoAllocMap)
	// allocs4ddb34ee.Add(mem4ddb34ee)

	var cid_allocs *cgoAllocMap
	ref4ddb34ee.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var cwidth_allocs *cgoAllocMap
	ref4ddb34ee.width, cwidth_allocs = (C.int)(x.gWidth), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cwidth_allocs)
	x.gWidth = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref4ddb34ee.height, cheight_allocs = (C.int)(x.gHeight), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cheight_allocs)
	x.gHeight = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref4ddb34ee.mipmaps, cmipmaps_allocs = (C.int)(x.gMipmaps), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cmipmaps_allocs)
	x.gMipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref4ddb34ee.format, cformat_allocs = (C.int)(x.gFormat), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cformat_allocs)
	x.gFormat = *new(int32)

	x.ref4ddb34ee = ref4ddb34ee
	x.allocs4ddb34ee = allocs4ddb34ee

	return ref4ddb34ee, allocs4ddb34ee
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gTexture) passValue() (C.Texture, *cgoAllocMap) {
	if x.ref4ddb34ee != nil {
		return *x.ref4ddb34ee, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gTexture) convert() *Texture {
	if x.ref4ddb34ee != nil {
		return (*Texture)(unsafe.Pointer(x.ref4ddb34ee))
	}
	x.passRef()
	return (*Texture)(unsafe.Pointer(x.ref4ddb34ee))
}

// NewTexture new Go object and Mapping to C object.
func NewTexture(cId uint32, cWidth int32, cHeight int32, cMipmaps int32, cFormat int32) Texture {
	obj := *new(gTexture)
	obj.gId = cId
	obj.gWidth = cWidth
	obj.gHeight = cHeight
	obj.gMipmaps = cMipmaps
	obj.gFormat = cFormat

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocTexture.")
	}
	return *(*Texture)(unsafe.Pointer(ret0))
}

// AllocTexture new Go object and Mapping to C object.
func AllocTexture(cId uint32, cWidth int32, cHeight int32, cMipmaps int32, cFormat int32) (*Texture, *cgoAllocMap) {
	obj := *new(gTexture)
	obj.gId = cId
	obj.gWidth = cWidth
	obj.gHeight = cHeight
	obj.gMipmaps = cMipmaps
	obj.gFormat = cFormat

	ret0, alloc0 := obj.passRef()
	ret1 := (*Texture)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Texture) Index(index int32) *Texture {
	ptr1 := (*Texture)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfTextureValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Texture) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Texture) {
			a.Free()
		})
	}
}

// newTexture2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newTexture2DRef(ref unsafe.Pointer) *gTexture2D {
	if ref == nil {
		return nil
	}
	obj := new(gTexture2D)
	obj.ref4ddb34ee = (*C.Texture)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gTexture2D) passRef() (*C.Texture, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4ddb34ee != nil {
		if x.allocs4ddb34ee != nil {
			return x.ref4ddb34ee, x.allocs4ddb34ee.(*cgoAllocMap)
		} else {
			return x.ref4ddb34ee, nil
		}
	}
	mem4ddb34ee := unsafe.Pointer(new(C.Texture))
	ref4ddb34ee := (*C.Texture)(mem4ddb34ee)
	allocs4ddb34ee := new(cgoAllocMap)
	// allocs4ddb34ee.Add(mem4ddb34ee)

	var cid_allocs *cgoAllocMap
	ref4ddb34ee.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var cwidth_allocs *cgoAllocMap
	ref4ddb34ee.width, cwidth_allocs = (C.int)(x.gWidth), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cwidth_allocs)
	x.gWidth = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref4ddb34ee.height, cheight_allocs = (C.int)(x.gHeight), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cheight_allocs)
	x.gHeight = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref4ddb34ee.mipmaps, cmipmaps_allocs = (C.int)(x.gMipmaps), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cmipmaps_allocs)
	x.gMipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref4ddb34ee.format, cformat_allocs = (C.int)(x.gFormat), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cformat_allocs)
	x.gFormat = *new(int32)

	x.ref4ddb34ee = ref4ddb34ee
	x.allocs4ddb34ee = allocs4ddb34ee

	return ref4ddb34ee, allocs4ddb34ee
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gTexture2D) passValue() (C.Texture, *cgoAllocMap) {
	if x.ref4ddb34ee != nil {
		return *x.ref4ddb34ee, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gTexture2D) convert() *Texture2D {
	if x.ref4ddb34ee != nil {
		return (*Texture2D)(unsafe.Pointer(x.ref4ddb34ee))
	}
	x.passRef()
	return (*Texture2D)(unsafe.Pointer(x.ref4ddb34ee))
}

// NewTexture2D new Go object and Mapping to C object.
func NewTexture2D(cId uint32, cWidth int32, cHeight int32, cMipmaps int32, cFormat int32) Texture2D {
	obj := *new(gTexture2D)
	obj.gId = cId
	obj.gWidth = cWidth
	obj.gHeight = cHeight
	obj.gMipmaps = cMipmaps
	obj.gFormat = cFormat

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocTexture2D.")
	}
	return *(*Texture2D)(unsafe.Pointer(ret0))
}

// AllocTexture2D new Go object and Mapping to C object.
func AllocTexture2D(cId uint32, cWidth int32, cHeight int32, cMipmaps int32, cFormat int32) (*Texture2D, *cgoAllocMap) {
	obj := *new(gTexture2D)
	obj.gId = cId
	obj.gWidth = cWidth
	obj.gHeight = cHeight
	obj.gMipmaps = cMipmaps
	obj.gFormat = cFormat

	ret0, alloc0 := obj.passRef()
	ret1 := (*Texture2D)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Texture2D) Index(index int32) *Texture2D {
	ptr1 := (*Texture2D)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfTextureValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Texture2D) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Texture2D) {
			a.Free()
		})
	}
}

// newTextureCubemapRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newTextureCubemapRef(ref unsafe.Pointer) *gTextureCubemap {
	if ref == nil {
		return nil
	}
	obj := new(gTextureCubemap)
	obj.ref4ddb34ee = (*C.Texture)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gTextureCubemap) passRef() (*C.Texture, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4ddb34ee != nil {
		if x.allocs4ddb34ee != nil {
			return x.ref4ddb34ee, x.allocs4ddb34ee.(*cgoAllocMap)
		} else {
			return x.ref4ddb34ee, nil
		}
	}
	mem4ddb34ee := unsafe.Pointer(new(C.Texture))
	ref4ddb34ee := (*C.Texture)(mem4ddb34ee)
	allocs4ddb34ee := new(cgoAllocMap)
	// allocs4ddb34ee.Add(mem4ddb34ee)

	var cid_allocs *cgoAllocMap
	ref4ddb34ee.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var cwidth_allocs *cgoAllocMap
	ref4ddb34ee.width, cwidth_allocs = (C.int)(x.gWidth), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cwidth_allocs)
	x.gWidth = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref4ddb34ee.height, cheight_allocs = (C.int)(x.gHeight), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cheight_allocs)
	x.gHeight = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref4ddb34ee.mipmaps, cmipmaps_allocs = (C.int)(x.gMipmaps), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cmipmaps_allocs)
	x.gMipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref4ddb34ee.format, cformat_allocs = (C.int)(x.gFormat), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cformat_allocs)
	x.gFormat = *new(int32)

	x.ref4ddb34ee = ref4ddb34ee
	x.allocs4ddb34ee = allocs4ddb34ee

	return ref4ddb34ee, allocs4ddb34ee
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gTextureCubemap) passValue() (C.Texture, *cgoAllocMap) {
	if x.ref4ddb34ee != nil {
		return *x.ref4ddb34ee, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gTextureCubemap) convert() *TextureCubemap {
	if x.ref4ddb34ee != nil {
		return (*TextureCubemap)(unsafe.Pointer(x.ref4ddb34ee))
	}
	x.passRef()
	return (*TextureCubemap)(unsafe.Pointer(x.ref4ddb34ee))
}

// NewTextureCubemap new Go object and Mapping to C object.
func NewTextureCubemap(cId uint32, cWidth int32, cHeight int32, cMipmaps int32, cFormat int32) TextureCubemap {
	obj := *new(gTextureCubemap)
	obj.gId = cId
	obj.gWidth = cWidth
	obj.gHeight = cHeight
	obj.gMipmaps = cMipmaps
	obj.gFormat = cFormat

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocTextureCubemap.")
	}
	return *(*TextureCubemap)(unsafe.Pointer(ret0))
}

// AllocTextureCubemap new Go object and Mapping to C object.
func AllocTextureCubemap(cId uint32, cWidth int32, cHeight int32, cMipmaps int32, cFormat int32) (*TextureCubemap, *cgoAllocMap) {
	obj := *new(gTextureCubemap)
	obj.gId = cId
	obj.gWidth = cWidth
	obj.gHeight = cHeight
	obj.gMipmaps = cMipmaps
	obj.gFormat = cFormat

	ret0, alloc0 := obj.passRef()
	ret1 := (*TextureCubemap)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *TextureCubemap) Index(index int32) *TextureCubemap {
	ptr1 := (*TextureCubemap)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfTextureValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *TextureCubemap) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*TextureCubemap) {
			a.Free()
		})
	}
}

// allocRenderTextureMemory allocates memory for type C.RenderTexture in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderTextureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderTextureValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRenderTextureValue = unsafe.Sizeof([1]C.RenderTexture{})

// newRenderTextureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newRenderTextureRef(ref unsafe.Pointer) *gRenderTexture {
	if ref == nil {
		return nil
	}
	obj := new(gRenderTexture)
	obj.ref24cb7f02 = (*C.RenderTexture)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gRenderTexture) passRef() (*C.RenderTexture, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref24cb7f02 != nil {
		if x.allocs24cb7f02 != nil {
			return x.ref24cb7f02, x.allocs24cb7f02.(*cgoAllocMap)
		} else {
			return x.ref24cb7f02, nil
		}
	}
	mem24cb7f02 := unsafe.Pointer(new(C.RenderTexture))
	ref24cb7f02 := (*C.RenderTexture)(mem24cb7f02)
	allocs24cb7f02 := new(cgoAllocMap)
	// allocs24cb7f02.Add(mem24cb7f02)

	var cid_allocs *cgoAllocMap
	ref24cb7f02.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs24cb7f02.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var ctexture_allocs *cgoAllocMap
	ref24cb7f02.texture, ctexture_allocs = x.gTexture.passValue()
	allocs24cb7f02.Borrow(ctexture_allocs)
	x.gTexture = *new(gTexture)

	var cdepth_allocs *cgoAllocMap
	ref24cb7f02.depth, cdepth_allocs = x.gDepth.passValue()
	allocs24cb7f02.Borrow(cdepth_allocs)
	x.gDepth = *new(gTexture)

	x.ref24cb7f02 = ref24cb7f02
	x.allocs24cb7f02 = allocs24cb7f02

	return ref24cb7f02, allocs24cb7f02
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gRenderTexture) passValue() (C.RenderTexture, *cgoAllocMap) {
	if x.ref24cb7f02 != nil {
		return *x.ref24cb7f02, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gRenderTexture) convert() *RenderTexture {
	if x.ref24cb7f02 != nil {
		return (*RenderTexture)(unsafe.Pointer(x.ref24cb7f02))
	}
	x.passRef()
	return (*RenderTexture)(unsafe.Pointer(x.ref24cb7f02))
}

// NewRenderTexture new Go object and Mapping to C object.
func NewRenderTexture(cId uint32, cTexture Texture, cDepth Texture) RenderTexture {
	obj := *new(gRenderTexture)
	obj.gId = cId
	obj.gTexture = *newTextureRef(unsafe.Pointer(&cTexture))
	obj.gDepth = *newTextureRef(unsafe.Pointer(&cDepth))

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocRenderTexture.")
	}
	return *(*RenderTexture)(unsafe.Pointer(ret0))
}

// AllocRenderTexture new Go object and Mapping to C object.
func AllocRenderTexture(cId uint32, cTexture Texture, cDepth Texture) (*RenderTexture, *cgoAllocMap) {
	obj := *new(gRenderTexture)
	obj.gId = cId
	obj.gTexture = *newTextureRef(unsafe.Pointer(&cTexture))
	obj.gDepth = *newTextureRef(unsafe.Pointer(&cDepth))

	ret0, alloc0 := obj.passRef()
	ret1 := (*RenderTexture)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *RenderTexture) Index(index int32) *RenderTexture {
	ptr1 := (*RenderTexture)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfRenderTextureValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *RenderTexture) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*RenderTexture) {
			a.Free()
		})
	}
}

// newRenderTexture2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newRenderTexture2DRef(ref unsafe.Pointer) *gRenderTexture2D {
	if ref == nil {
		return nil
	}
	obj := new(gRenderTexture2D)
	obj.ref24cb7f02 = (*C.RenderTexture)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gRenderTexture2D) passRef() (*C.RenderTexture, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref24cb7f02 != nil {
		if x.allocs24cb7f02 != nil {
			return x.ref24cb7f02, x.allocs24cb7f02.(*cgoAllocMap)
		} else {
			return x.ref24cb7f02, nil
		}
	}
	mem24cb7f02 := unsafe.Pointer(new(C.RenderTexture))
	ref24cb7f02 := (*C.RenderTexture)(mem24cb7f02)
	allocs24cb7f02 := new(cgoAllocMap)
	// allocs24cb7f02.Add(mem24cb7f02)

	var cid_allocs *cgoAllocMap
	ref24cb7f02.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs24cb7f02.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var ctexture_allocs *cgoAllocMap
	ref24cb7f02.texture, ctexture_allocs = x.gTexture.passValue()
	allocs24cb7f02.Borrow(ctexture_allocs)
	x.gTexture = *new(gTexture)

	var cdepth_allocs *cgoAllocMap
	ref24cb7f02.depth, cdepth_allocs = x.gDepth.passValue()
	allocs24cb7f02.Borrow(cdepth_allocs)
	x.gDepth = *new(gTexture)

	x.ref24cb7f02 = ref24cb7f02
	x.allocs24cb7f02 = allocs24cb7f02

	return ref24cb7f02, allocs24cb7f02
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gRenderTexture2D) passValue() (C.RenderTexture, *cgoAllocMap) {
	if x.ref24cb7f02 != nil {
		return *x.ref24cb7f02, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gRenderTexture2D) convert() *RenderTexture2D {
	if x.ref24cb7f02 != nil {
		return (*RenderTexture2D)(unsafe.Pointer(x.ref24cb7f02))
	}
	x.passRef()
	return (*RenderTexture2D)(unsafe.Pointer(x.ref24cb7f02))
}

// NewRenderTexture2D new Go object and Mapping to C object.
func NewRenderTexture2D(cId uint32, cTexture Texture, cDepth Texture) RenderTexture2D {
	obj := *new(gRenderTexture2D)
	obj.gId = cId
	obj.gTexture = *newTextureRef(unsafe.Pointer(&cTexture))
	obj.gDepth = *newTextureRef(unsafe.Pointer(&cDepth))

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocRenderTexture2D.")
	}
	return *(*RenderTexture2D)(unsafe.Pointer(ret0))
}

// AllocRenderTexture2D new Go object and Mapping to C object.
func AllocRenderTexture2D(cId uint32, cTexture Texture, cDepth Texture) (*RenderTexture2D, *cgoAllocMap) {
	obj := *new(gRenderTexture2D)
	obj.gId = cId
	obj.gTexture = *newTextureRef(unsafe.Pointer(&cTexture))
	obj.gDepth = *newTextureRef(unsafe.Pointer(&cDepth))

	ret0, alloc0 := obj.passRef()
	ret1 := (*RenderTexture2D)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *RenderTexture2D) Index(index int32) *RenderTexture2D {
	ptr1 := (*RenderTexture2D)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfRenderTextureValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *RenderTexture2D) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*RenderTexture2D) {
			a.Free()
		})
	}
}

// allocNPatchInfoMemory allocates memory for type C.NPatchInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocNPatchInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfNPatchInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfNPatchInfoValue = unsafe.Sizeof([1]C.NPatchInfo{})

// newNPatchInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newNPatchInfoRef(ref unsafe.Pointer) *gNPatchInfo {
	if ref == nil {
		return nil
	}
	obj := new(gNPatchInfo)
	obj.ref78104a03 = (*C.NPatchInfo)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gNPatchInfo) passRef() (*C.NPatchInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref78104a03 != nil {
		if x.allocs78104a03 != nil {
			return x.ref78104a03, x.allocs78104a03.(*cgoAllocMap)
		} else {
			return x.ref78104a03, nil
		}
	}
	mem78104a03 := unsafe.Pointer(new(C.NPatchInfo))
	ref78104a03 := (*C.NPatchInfo)(mem78104a03)
	allocs78104a03 := new(cgoAllocMap)
	// allocs78104a03.Add(mem78104a03)

	var csource_allocs *cgoAllocMap
	ref78104a03.source, csource_allocs = x.gSource.passValue()
	allocs78104a03.Borrow(csource_allocs)
	x.gSource = *new(gRectangle)

	var cleft_allocs *cgoAllocMap
	ref78104a03.left, cleft_allocs = (C.int)(x.gLeft), cgoAllocsUnknown
	allocs78104a03.Borrow(cleft_allocs)
	x.gLeft = *new(int32)

	var ctop_allocs *cgoAllocMap
	ref78104a03.top, ctop_allocs = (C.int)(x.gTop), cgoAllocsUnknown
	allocs78104a03.Borrow(ctop_allocs)
	x.gTop = *new(int32)

	var cright_allocs *cgoAllocMap
	ref78104a03.right, cright_allocs = (C.int)(x.gRight), cgoAllocsUnknown
	allocs78104a03.Borrow(cright_allocs)
	x.gRight = *new(int32)

	var cbottom_allocs *cgoAllocMap
	ref78104a03.bottom, cbottom_allocs = (C.int)(x.gBottom), cgoAllocsUnknown
	allocs78104a03.Borrow(cbottom_allocs)
	x.gBottom = *new(int32)

	var c_type_allocs *cgoAllocMap
	ref78104a03._type, c_type_allocs = (C.int)(x.gType), cgoAllocsUnknown
	allocs78104a03.Borrow(c_type_allocs)
	x.gType = *new(int32)

	x.ref78104a03 = ref78104a03
	x.allocs78104a03 = allocs78104a03

	return ref78104a03, allocs78104a03
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gNPatchInfo) passValue() (C.NPatchInfo, *cgoAllocMap) {
	if x.ref78104a03 != nil {
		return *x.ref78104a03, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gNPatchInfo) convert() *NPatchInfo {
	if x.ref78104a03 != nil {
		return (*NPatchInfo)(unsafe.Pointer(x.ref78104a03))
	}
	x.passRef()
	return (*NPatchInfo)(unsafe.Pointer(x.ref78104a03))
}

// NewNPatchInfo new Go object and Mapping to C object.
func NewNPatchInfo(cSource Rectangle, cLeft int32, cTop int32, cRight int32, cBottom int32, cType int32) NPatchInfo {
	obj := *new(gNPatchInfo)
	obj.gSource = *newRectangleRef(unsafe.Pointer(&cSource))
	obj.gLeft = cLeft
	obj.gTop = cTop
	obj.gRight = cRight
	obj.gBottom = cBottom
	obj.gType = cType

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocNPatchInfo.")
	}
	return *(*NPatchInfo)(unsafe.Pointer(ret0))
}

// AllocNPatchInfo new Go object and Mapping to C object.
func AllocNPatchInfo(cSource Rectangle, cLeft int32, cTop int32, cRight int32, cBottom int32, cType int32) (*NPatchInfo, *cgoAllocMap) {
	obj := *new(gNPatchInfo)
	obj.gSource = *newRectangleRef(unsafe.Pointer(&cSource))
	obj.gLeft = cLeft
	obj.gTop = cTop
	obj.gRight = cRight
	obj.gBottom = cBottom
	obj.gType = cType

	ret0, alloc0 := obj.passRef()
	ret1 := (*NPatchInfo)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *NPatchInfo) Index(index int32) *NPatchInfo {
	ptr1 := (*NPatchInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfNPatchInfoValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *NPatchInfo) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*NPatchInfo) {
			a.Free()
		})
	}
}

// allocCharInfoMemory allocates memory for type C.CharInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCharInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCharInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCharInfoValue = unsafe.Sizeof([1]C.CharInfo{})

// newCharInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newCharInfoRef(ref unsafe.Pointer) *gCharInfo {
	if ref == nil {
		return nil
	}
	obj := new(gCharInfo)
	obj.ref702c36c0 = (*C.CharInfo)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gCharInfo) passRef() (*C.CharInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref702c36c0 != nil {
		if x.allocs702c36c0 != nil {
			return x.ref702c36c0, x.allocs702c36c0.(*cgoAllocMap)
		} else {
			return x.ref702c36c0, nil
		}
	}
	mem702c36c0 := unsafe.Pointer(new(C.CharInfo))
	ref702c36c0 := (*C.CharInfo)(mem702c36c0)
	allocs702c36c0 := new(cgoAllocMap)
	// allocs702c36c0.Add(mem702c36c0)

	var cvalue_allocs *cgoAllocMap
	ref702c36c0.value, cvalue_allocs = (C.int)(x.gValue), cgoAllocsUnknown
	allocs702c36c0.Borrow(cvalue_allocs)
	x.gValue = *new(int32)

	var coffsetX_allocs *cgoAllocMap
	ref702c36c0.offsetX, coffsetX_allocs = (C.int)(x.gOffsetX), cgoAllocsUnknown
	allocs702c36c0.Borrow(coffsetX_allocs)
	x.gOffsetX = *new(int32)

	var coffsetY_allocs *cgoAllocMap
	ref702c36c0.offsetY, coffsetY_allocs = (C.int)(x.gOffsetY), cgoAllocsUnknown
	allocs702c36c0.Borrow(coffsetY_allocs)
	x.gOffsetY = *new(int32)

	var cadvanceX_allocs *cgoAllocMap
	ref702c36c0.advanceX, cadvanceX_allocs = (C.int)(x.gAdvanceX), cgoAllocsUnknown
	allocs702c36c0.Borrow(cadvanceX_allocs)
	x.gAdvanceX = *new(int32)

	var cimage_allocs *cgoAllocMap
	ref702c36c0.image, cimage_allocs = x.gImage.passValue()
	allocs702c36c0.Borrow(cimage_allocs)
	x.gImage = *new(gImage)

	x.ref702c36c0 = ref702c36c0
	x.allocs702c36c0 = allocs702c36c0

	return ref702c36c0, allocs702c36c0
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gCharInfo) passValue() (C.CharInfo, *cgoAllocMap) {
	if x.ref702c36c0 != nil {
		return *x.ref702c36c0, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gCharInfo) convert() *CharInfo {
	if x.ref702c36c0 != nil {
		return (*CharInfo)(unsafe.Pointer(x.ref702c36c0))
	}
	x.passRef()
	return (*CharInfo)(unsafe.Pointer(x.ref702c36c0))
}

// NewCharInfo new Go object and Mapping to C object.
func NewCharInfo(cValue int32, cOffsetX int32, cOffsetY int32, cAdvanceX int32, cImage Image) CharInfo {
	obj := *new(gCharInfo)
	obj.gValue = cValue
	obj.gOffsetX = cOffsetX
	obj.gOffsetY = cOffsetY
	obj.gAdvanceX = cAdvanceX
	obj.gImage = *newImageRef(unsafe.Pointer(&cImage))

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocCharInfo.")
	}
	return *(*CharInfo)(unsafe.Pointer(ret0))
}

// AllocCharInfo new Go object and Mapping to C object.
func AllocCharInfo(cValue int32, cOffsetX int32, cOffsetY int32, cAdvanceX int32, cImage Image) (*CharInfo, *cgoAllocMap) {
	obj := *new(gCharInfo)
	obj.gValue = cValue
	obj.gOffsetX = cOffsetX
	obj.gOffsetY = cOffsetY
	obj.gAdvanceX = cAdvanceX
	obj.gImage = *newImageRef(unsafe.Pointer(&cImage))

	ret0, alloc0 := obj.passRef()
	ret1 := (*CharInfo)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *CharInfo) Index(index int32) *CharInfo {
	ptr1 := (*CharInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfCharInfoValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *CharInfo) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*CharInfo) {
			a.Free()
		})
	}
}

// allocFontMemory allocates memory for type C.Font in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFontMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFontValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFontValue = unsafe.Sizeof([1]C.Font{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSRectangle transforms a sliced Go data structure into plain C format.
func unpackSRectangle(x []gRectangle) (unpacked *C.Rectangle, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Rectangle) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRectangleMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Rectangle)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].passValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Rectangle)(h.Data)
	return
}

// unpackSCharInfo transforms a sliced Go data structure into plain C format.
func unpackSCharInfo(x []gCharInfo) (unpacked *C.CharInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.CharInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCharInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.CharInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].passValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.CharInfo)(h.Data)
	return
}

// newFontRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newFontRef(ref unsafe.Pointer) *gFont {
	if ref == nil {
		return nil
	}
	obj := new(gFont)
	obj.ref70a6a7ec = (*C.Font)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gFont) passRef() (*C.Font, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref70a6a7ec != nil {
		if x.allocs70a6a7ec != nil {
			return x.ref70a6a7ec, x.allocs70a6a7ec.(*cgoAllocMap)
		} else {
			return x.ref70a6a7ec, nil
		}
	}
	mem70a6a7ec := unsafe.Pointer(new(C.Font))
	ref70a6a7ec := (*C.Font)(mem70a6a7ec)
	allocs70a6a7ec := new(cgoAllocMap)
	// allocs70a6a7ec.Add(mem70a6a7ec)

	var cbaseSize_allocs *cgoAllocMap
	ref70a6a7ec.baseSize, cbaseSize_allocs = (C.int)(x.gBaseSize), cgoAllocsUnknown
	allocs70a6a7ec.Borrow(cbaseSize_allocs)
	x.gBaseSize = *new(int32)

	var ccharsCount_allocs *cgoAllocMap
	ref70a6a7ec.charsCount, ccharsCount_allocs = (C.int)(x.gCharsCount), cgoAllocsUnknown
	allocs70a6a7ec.Borrow(ccharsCount_allocs)
	x.gCharsCount = *new(int32)

	var ccharsPadding_allocs *cgoAllocMap
	ref70a6a7ec.charsPadding, ccharsPadding_allocs = (C.int)(x.gCharsPadding), cgoAllocsUnknown
	allocs70a6a7ec.Borrow(ccharsPadding_allocs)
	x.gCharsPadding = *new(int32)

	var ctexture_allocs *cgoAllocMap
	ref70a6a7ec.texture, ctexture_allocs = x.gTexture.passValue()
	allocs70a6a7ec.Borrow(ctexture_allocs)
	x.gTexture = *new(gTexture2D)

	var crecs_allocs *cgoAllocMap
	ref70a6a7ec.recs, crecs_allocs = unpackSRectangle(x.gRecs)
	allocs70a6a7ec.Borrow(crecs_allocs)
	x.gRecs = *new([]gRectangle)

	var cchars_allocs *cgoAllocMap
	ref70a6a7ec.chars, cchars_allocs = unpackSCharInfo(x.gChars)
	allocs70a6a7ec.Borrow(cchars_allocs)
	x.gChars = *new([]gCharInfo)

	x.ref70a6a7ec = ref70a6a7ec
	x.allocs70a6a7ec = allocs70a6a7ec

	return ref70a6a7ec, allocs70a6a7ec
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gFont) passValue() (C.Font, *cgoAllocMap) {
	if x.ref70a6a7ec != nil {
		return *x.ref70a6a7ec, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gFont) convert() *Font {
	if x.ref70a6a7ec != nil {
		return (*Font)(unsafe.Pointer(x.ref70a6a7ec))
	}
	x.passRef()
	return (*Font)(unsafe.Pointer(x.ref70a6a7ec))
}

// NewFont new Go object and Mapping to C object.
func NewFont(cBaseSize int32, cCharsCount int32, cCharsPadding int32, cTexture Texture2D, cRecs []Rectangle, cChars []CharInfo) Font {
	obj := *new(gFont)
	obj.gBaseSize = cBaseSize
	obj.gCharsCount = cCharsCount
	obj.gCharsPadding = cCharsPadding
	obj.gTexture = *newTexture2DRef(unsafe.Pointer(&cTexture))

	var recs0 []gRectangle
	for i0 := range cRecs {
		p0 := *newRectangleRef(unsafe.Pointer(&cRecs[i0]))
		recs0 = append(recs0, p0)
	}
	obj.gRecs = recs0

	var chars0 []gCharInfo
	for i0 := range cChars {
		p0 := *newCharInfoRef(unsafe.Pointer(&cChars[i0]))
		chars0 = append(chars0, p0)
	}
	obj.gChars = chars0

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocFont.")
	}
	return *(*Font)(unsafe.Pointer(ret0))
}

// AllocFont new Go object and Mapping to C object.
func AllocFont(cBaseSize int32, cCharsCount int32, cCharsPadding int32, cTexture Texture2D, cRecs []Rectangle, cChars []CharInfo) (*Font, *cgoAllocMap) {
	obj := *new(gFont)
	obj.gBaseSize = cBaseSize
	obj.gCharsCount = cCharsCount
	obj.gCharsPadding = cCharsPadding
	obj.gTexture = *newTexture2DRef(unsafe.Pointer(&cTexture))

	var recs0 []gRectangle
	for i0 := range cRecs {
		p0 := *newRectangleRef(unsafe.Pointer(&cRecs[i0]))
		recs0 = append(recs0, p0)
	}
	obj.gRecs = recs0

	var chars0 []gCharInfo
	for i0 := range cChars {
		p0 := *newCharInfoRef(unsafe.Pointer(&cChars[i0]))
		chars0 = append(chars0, p0)
	}
	obj.gChars = chars0

	ret0, alloc0 := obj.passRef()
	ret1 := (*Font)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Font) Index(index int32) *Font {
	ptr1 := (*Font)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfFontValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Font) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Font) {
			a.Free()
		})
	}
}

// Recs returns a reference to C object within a struct
func (x *Font) Recser(index int32) *Rectangle {
	var ret *Rectangle

	ptr0 := x.Recs
	ptr1 := (*C.Rectangle)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfRectangleValue)))
	ret = newRectangleRef(unsafe.Pointer(ptr1)).convert()

	return ret
}

// Chars returns a reference to C object within a struct
func (x *Font) Charser(index int32) *CharInfo {
	var ret *CharInfo

	ptr0 := x.Chars
	ptr1 := (*C.CharInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfCharInfoValue)))
	ret = newCharInfoRef(unsafe.Pointer(ptr1)).convert()

	return ret
}

// allocCamera3DMemory allocates memory for type C.Camera3D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCamera3DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCamera3DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCamera3DValue = unsafe.Sizeof([1]C.Camera3D{})

// newCamera3DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newCamera3DRef(ref unsafe.Pointer) *gCamera3D {
	if ref == nil {
		return nil
	}
	obj := new(gCamera3D)
	obj.ref7b09036 = (*C.Camera3D)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gCamera3D) passRef() (*C.Camera3D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7b09036 != nil {
		if x.allocs7b09036 != nil {
			return x.ref7b09036, x.allocs7b09036.(*cgoAllocMap)
		} else {
			return x.ref7b09036, nil
		}
	}
	mem7b09036 := unsafe.Pointer(new(C.Camera3D))
	ref7b09036 := (*C.Camera3D)(mem7b09036)
	allocs7b09036 := new(cgoAllocMap)
	// allocs7b09036.Add(mem7b09036)

	var cposition_allocs *cgoAllocMap
	ref7b09036.position, cposition_allocs = x.gPosition.passValue()
	allocs7b09036.Borrow(cposition_allocs)
	x.gPosition = *new(gVector3)

	var ctarget_allocs *cgoAllocMap
	ref7b09036.target, ctarget_allocs = x.gTarget.passValue()
	allocs7b09036.Borrow(ctarget_allocs)
	x.gTarget = *new(gVector3)

	var cup_allocs *cgoAllocMap
	ref7b09036.up, cup_allocs = x.gUp.passValue()
	allocs7b09036.Borrow(cup_allocs)
	x.gUp = *new(gVector3)

	var cfovy_allocs *cgoAllocMap
	ref7b09036.fovy, cfovy_allocs = (C.float)(x.gFovy), cgoAllocsUnknown
	allocs7b09036.Borrow(cfovy_allocs)
	x.gFovy = *new(float32)

	var c_type_allocs *cgoAllocMap
	ref7b09036._type, c_type_allocs = (C.int)(x.gType), cgoAllocsUnknown
	allocs7b09036.Borrow(c_type_allocs)
	x.gType = *new(int32)

	x.ref7b09036 = ref7b09036
	x.allocs7b09036 = allocs7b09036

	return ref7b09036, allocs7b09036
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gCamera3D) passValue() (C.Camera3D, *cgoAllocMap) {
	if x.ref7b09036 != nil {
		return *x.ref7b09036, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gCamera3D) convert() *Camera3D {
	if x.ref7b09036 != nil {
		return (*Camera3D)(unsafe.Pointer(x.ref7b09036))
	}
	x.passRef()
	return (*Camera3D)(unsafe.Pointer(x.ref7b09036))
}

// NewCamera3D new Go object and Mapping to C object.
func NewCamera3D(cPosition Vector3, cTarget Vector3, cUp Vector3, cFovy float32, cType int32) Camera3D {
	obj := *new(gCamera3D)
	obj.gPosition = *newVector3Ref(unsafe.Pointer(&cPosition))
	obj.gTarget = *newVector3Ref(unsafe.Pointer(&cTarget))
	obj.gUp = *newVector3Ref(unsafe.Pointer(&cUp))
	obj.gFovy = cFovy
	obj.gType = cType

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocCamera3D.")
	}
	return *(*Camera3D)(unsafe.Pointer(ret0))
}

// AllocCamera3D new Go object and Mapping to C object.
func AllocCamera3D(cPosition Vector3, cTarget Vector3, cUp Vector3, cFovy float32, cType int32) (*Camera3D, *cgoAllocMap) {
	obj := *new(gCamera3D)
	obj.gPosition = *newVector3Ref(unsafe.Pointer(&cPosition))
	obj.gTarget = *newVector3Ref(unsafe.Pointer(&cTarget))
	obj.gUp = *newVector3Ref(unsafe.Pointer(&cUp))
	obj.gFovy = cFovy
	obj.gType = cType

	ret0, alloc0 := obj.passRef()
	ret1 := (*Camera3D)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Camera3D) Index(index int32) *Camera3D {
	ptr1 := (*Camera3D)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfCamera3DValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Camera3D) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Camera3D) {
			a.Free()
		})
	}
}

// newCameraRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newCameraRef(ref unsafe.Pointer) *gCamera {
	if ref == nil {
		return nil
	}
	obj := new(gCamera)
	obj.ref7b09036 = (*C.Camera3D)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gCamera) passRef() (*C.Camera3D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7b09036 != nil {
		if x.allocs7b09036 != nil {
			return x.ref7b09036, x.allocs7b09036.(*cgoAllocMap)
		} else {
			return x.ref7b09036, nil
		}
	}
	mem7b09036 := unsafe.Pointer(new(C.Camera3D))
	ref7b09036 := (*C.Camera3D)(mem7b09036)
	allocs7b09036 := new(cgoAllocMap)
	// allocs7b09036.Add(mem7b09036)

	var cposition_allocs *cgoAllocMap
	ref7b09036.position, cposition_allocs = x.gPosition.passValue()
	allocs7b09036.Borrow(cposition_allocs)
	x.gPosition = *new(gVector3)

	var ctarget_allocs *cgoAllocMap
	ref7b09036.target, ctarget_allocs = x.gTarget.passValue()
	allocs7b09036.Borrow(ctarget_allocs)
	x.gTarget = *new(gVector3)

	var cup_allocs *cgoAllocMap
	ref7b09036.up, cup_allocs = x.gUp.passValue()
	allocs7b09036.Borrow(cup_allocs)
	x.gUp = *new(gVector3)

	var cfovy_allocs *cgoAllocMap
	ref7b09036.fovy, cfovy_allocs = (C.float)(x.gFovy), cgoAllocsUnknown
	allocs7b09036.Borrow(cfovy_allocs)
	x.gFovy = *new(float32)

	var c_type_allocs *cgoAllocMap
	ref7b09036._type, c_type_allocs = (C.int)(x.gType), cgoAllocsUnknown
	allocs7b09036.Borrow(c_type_allocs)
	x.gType = *new(int32)

	x.ref7b09036 = ref7b09036
	x.allocs7b09036 = allocs7b09036

	return ref7b09036, allocs7b09036
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gCamera) passValue() (C.Camera3D, *cgoAllocMap) {
	if x.ref7b09036 != nil {
		return *x.ref7b09036, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gCamera) convert() *Camera {
	if x.ref7b09036 != nil {
		return (*Camera)(unsafe.Pointer(x.ref7b09036))
	}
	x.passRef()
	return (*Camera)(unsafe.Pointer(x.ref7b09036))
}

// NewCamera new Go object and Mapping to C object.
func NewCamera(cPosition Vector3, cTarget Vector3, cUp Vector3, cFovy float32, cType int32) Camera {
	obj := *new(gCamera)
	obj.gPosition = *newVector3Ref(unsafe.Pointer(&cPosition))
	obj.gTarget = *newVector3Ref(unsafe.Pointer(&cTarget))
	obj.gUp = *newVector3Ref(unsafe.Pointer(&cUp))
	obj.gFovy = cFovy
	obj.gType = cType

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocCamera.")
	}
	return *(*Camera)(unsafe.Pointer(ret0))
}

// AllocCamera new Go object and Mapping to C object.
func AllocCamera(cPosition Vector3, cTarget Vector3, cUp Vector3, cFovy float32, cType int32) (*Camera, *cgoAllocMap) {
	obj := *new(gCamera)
	obj.gPosition = *newVector3Ref(unsafe.Pointer(&cPosition))
	obj.gTarget = *newVector3Ref(unsafe.Pointer(&cTarget))
	obj.gUp = *newVector3Ref(unsafe.Pointer(&cUp))
	obj.gFovy = cFovy
	obj.gType = cType

	ret0, alloc0 := obj.passRef()
	ret1 := (*Camera)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Camera) Index(index int32) *Camera {
	ptr1 := (*Camera)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfCamera3DValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Camera) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Camera) {
			a.Free()
		})
	}
}

// allocCamera2DMemory allocates memory for type C.Camera2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCamera2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCamera2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCamera2DValue = unsafe.Sizeof([1]C.Camera2D{})

// newCamera2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newCamera2DRef(ref unsafe.Pointer) *gCamera2D {
	if ref == nil {
		return nil
	}
	obj := new(gCamera2D)
	obj.ref1eaba177 = (*C.Camera2D)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gCamera2D) passRef() (*C.Camera2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1eaba177 != nil {
		if x.allocs1eaba177 != nil {
			return x.ref1eaba177, x.allocs1eaba177.(*cgoAllocMap)
		} else {
			return x.ref1eaba177, nil
		}
	}
	mem1eaba177 := unsafe.Pointer(new(C.Camera2D))
	ref1eaba177 := (*C.Camera2D)(mem1eaba177)
	allocs1eaba177 := new(cgoAllocMap)
	// allocs1eaba177.Add(mem1eaba177)

	var coffset_allocs *cgoAllocMap
	ref1eaba177.offset, coffset_allocs = x.gOffset.passValue()
	allocs1eaba177.Borrow(coffset_allocs)
	x.gOffset = *new(gVector2)

	var ctarget_allocs *cgoAllocMap
	ref1eaba177.target, ctarget_allocs = x.gTarget.passValue()
	allocs1eaba177.Borrow(ctarget_allocs)
	x.gTarget = *new(gVector2)

	var crotation_allocs *cgoAllocMap
	ref1eaba177.rotation, crotation_allocs = (C.float)(x.gRotation), cgoAllocsUnknown
	allocs1eaba177.Borrow(crotation_allocs)
	x.gRotation = *new(float32)

	var czoom_allocs *cgoAllocMap
	ref1eaba177.zoom, czoom_allocs = (C.float)(x.gZoom), cgoAllocsUnknown
	allocs1eaba177.Borrow(czoom_allocs)
	x.gZoom = *new(float32)

	x.ref1eaba177 = ref1eaba177
	x.allocs1eaba177 = allocs1eaba177

	return ref1eaba177, allocs1eaba177
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gCamera2D) passValue() (C.Camera2D, *cgoAllocMap) {
	if x.ref1eaba177 != nil {
		return *x.ref1eaba177, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gCamera2D) convert() *Camera2D {
	if x.ref1eaba177 != nil {
		return (*Camera2D)(unsafe.Pointer(x.ref1eaba177))
	}
	x.passRef()
	return (*Camera2D)(unsafe.Pointer(x.ref1eaba177))
}

// NewCamera2D new Go object and Mapping to C object.
func NewCamera2D(cOffset Vector2, cTarget Vector2, cRotation float32, cZoom float32) Camera2D {
	obj := *new(gCamera2D)
	obj.gOffset = *newVector2Ref(unsafe.Pointer(&cOffset))
	obj.gTarget = *newVector2Ref(unsafe.Pointer(&cTarget))
	obj.gRotation = cRotation
	obj.gZoom = cZoom

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocCamera2D.")
	}
	return *(*Camera2D)(unsafe.Pointer(ret0))
}

// AllocCamera2D new Go object and Mapping to C object.
func AllocCamera2D(cOffset Vector2, cTarget Vector2, cRotation float32, cZoom float32) (*Camera2D, *cgoAllocMap) {
	obj := *new(gCamera2D)
	obj.gOffset = *newVector2Ref(unsafe.Pointer(&cOffset))
	obj.gTarget = *newVector2Ref(unsafe.Pointer(&cTarget))
	obj.gRotation = cRotation
	obj.gZoom = cZoom

	ret0, alloc0 := obj.passRef()
	ret1 := (*Camera2D)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Camera2D) Index(index int32) *Camera2D {
	ptr1 := (*Camera2D)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfCamera2DValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Camera2D) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Camera2D) {
			a.Free()
		})
	}
}

// allocMeshMemory allocates memory for type C.Mesh in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMeshMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMeshValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMeshValue = unsafe.Sizeof([1]C.Mesh{})

// allocFloatMemory allocates memory for type C.float in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFloatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFloatValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFloatValue = unsafe.Sizeof([1]C.float{})

// unpackSFloat32 transforms a sliced Go data structure into plain C format.
func unpackSFloat32(x []float32) (unpacked *C.float, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.float) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocFloatMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.float)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0] = (C.float)(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.float)(h.Data)
	return
}

// allocUcharMemory allocates memory for type C.uchar in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUcharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUcharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfUcharValue = unsafe.Sizeof([1]C.uchar{})

// unpackSByte transforms a sliced Go data structure into plain C format.
func unpackSByte(x []byte) (unpacked *C.uchar, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.uchar) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocUcharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.uchar)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0] = (C.uchar)(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.uchar)(h.Data)
	return
}

// allocUshortMemory allocates memory for type C.ushort in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUshortMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUshortValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfUshortValue = unsafe.Sizeof([1]C.ushort{})

// unpackSUUint16 transforms a sliced Go data structure into plain C format.
func unpackSUUint16(x []uint16) (unpacked *C.ushort, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.ushort) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocUshortMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.ushort)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0] = (C.ushort)(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.ushort)(h.Data)
	return
}

// allocIntMemory allocates memory for type C.int in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIntMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIntValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfIntValue = unsafe.Sizeof([1]C.int{})

// unpackSInt32 transforms a sliced Go data structure into plain C format.
func unpackSInt32(x []int32) (unpacked *C.int, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.int) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocIntMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.int)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0] = (C.int)(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.int)(h.Data)
	return
}

// allocUintMemory allocates memory for type C.uint in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUintMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUintValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfUintValue = unsafe.Sizeof([1]C.uint{})

// unpackSUUint32 transforms a sliced Go data structure into plain C format.
func unpackSUUint32(x []uint32) (unpacked *C.uint, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.uint) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocUintMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.uint)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0] = (C.uint)(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.uint)(h.Data)
	return
}

// newMeshRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newMeshRef(ref unsafe.Pointer) *gMesh {
	if ref == nil {
		return nil
	}
	obj := new(gMesh)
	obj.ref415d9568 = (*C.Mesh)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gMesh) passRef() (*C.Mesh, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref415d9568 != nil {
		if x.allocs415d9568 != nil {
			return x.ref415d9568, x.allocs415d9568.(*cgoAllocMap)
		} else {
			return x.ref415d9568, nil
		}
	}
	mem415d9568 := unsafe.Pointer(new(C.Mesh))
	ref415d9568 := (*C.Mesh)(mem415d9568)
	allocs415d9568 := new(cgoAllocMap)
	// allocs415d9568.Add(mem415d9568)

	var cvertexCount_allocs *cgoAllocMap
	ref415d9568.vertexCount, cvertexCount_allocs = (C.int)(x.gVertexCount), cgoAllocsUnknown
	allocs415d9568.Borrow(cvertexCount_allocs)
	x.gVertexCount = *new(int32)

	var ctriangleCount_allocs *cgoAllocMap
	ref415d9568.triangleCount, ctriangleCount_allocs = (C.int)(x.gTriangleCount), cgoAllocsUnknown
	allocs415d9568.Borrow(ctriangleCount_allocs)
	x.gTriangleCount = *new(int32)

	var cvertices_allocs *cgoAllocMap
	ref415d9568.vertices, cvertices_allocs = unpackSFloat32(x.gVertices)
	allocs415d9568.Borrow(cvertices_allocs)
	x.gVertices = *new([]float32)

	var ctexcoords_allocs *cgoAllocMap
	ref415d9568.texcoords, ctexcoords_allocs = unpackSFloat32(x.gTexcoords)
	allocs415d9568.Borrow(ctexcoords_allocs)
	x.gTexcoords = *new([]float32)

	var ctexcoords2_allocs *cgoAllocMap
	ref415d9568.texcoords2, ctexcoords2_allocs = unpackSFloat32(x.gTexcoords2)
	allocs415d9568.Borrow(ctexcoords2_allocs)
	x.gTexcoords2 = *new([]float32)

	var cnormals_allocs *cgoAllocMap
	ref415d9568.normals, cnormals_allocs = unpackSFloat32(x.gNormals)
	allocs415d9568.Borrow(cnormals_allocs)
	x.gNormals = *new([]float32)

	var ctangents_allocs *cgoAllocMap
	ref415d9568.tangents, ctangents_allocs = unpackSFloat32(x.gTangents)
	allocs415d9568.Borrow(ctangents_allocs)
	x.gTangents = *new([]float32)

	var ccolors_allocs *cgoAllocMap
	ref415d9568.colors, ccolors_allocs = unpackSByte(x.gColors)
	allocs415d9568.Borrow(ccolors_allocs)
	x.gColors = *new([]byte)

	var cindices_allocs *cgoAllocMap
	ref415d9568.indices, cindices_allocs = unpackSUUint16(x.gIndices)
	allocs415d9568.Borrow(cindices_allocs)
	x.gIndices = *new([]uint16)

	var canimVertices_allocs *cgoAllocMap
	ref415d9568.animVertices, canimVertices_allocs = unpackSFloat32(x.gAnimVertices)
	allocs415d9568.Borrow(canimVertices_allocs)
	x.gAnimVertices = *new([]float32)

	var canimNormals_allocs *cgoAllocMap
	ref415d9568.animNormals, canimNormals_allocs = unpackSFloat32(x.gAnimNormals)
	allocs415d9568.Borrow(canimNormals_allocs)
	x.gAnimNormals = *new([]float32)

	var cboneIds_allocs *cgoAllocMap
	ref415d9568.boneIds, cboneIds_allocs = unpackSInt32(x.gBoneIds)
	allocs415d9568.Borrow(cboneIds_allocs)
	x.gBoneIds = *new([]int32)

	var cboneWeights_allocs *cgoAllocMap
	ref415d9568.boneWeights, cboneWeights_allocs = unpackSFloat32(x.gBoneWeights)
	allocs415d9568.Borrow(cboneWeights_allocs)
	x.gBoneWeights = *new([]float32)

	var cvaoId_allocs *cgoAllocMap
	ref415d9568.vaoId, cvaoId_allocs = (C.uint)(x.gVaoId), cgoAllocsUnknown
	allocs415d9568.Borrow(cvaoId_allocs)
	x.gVaoId = *new(uint32)

	var cvboId_allocs *cgoAllocMap
	ref415d9568.vboId, cvboId_allocs = unpackSUUint32(x.gVboId)
	allocs415d9568.Borrow(cvboId_allocs)
	x.gVboId = *new([]uint32)

	x.ref415d9568 = ref415d9568
	x.allocs415d9568 = allocs415d9568

	return ref415d9568, allocs415d9568
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gMesh) passValue() (C.Mesh, *cgoAllocMap) {
	if x.ref415d9568 != nil {
		return *x.ref415d9568, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gMesh) convert() *Mesh {
	if x.ref415d9568 != nil {
		return (*Mesh)(unsafe.Pointer(x.ref415d9568))
	}
	x.passRef()
	return (*Mesh)(unsafe.Pointer(x.ref415d9568))
}

// NewMesh new Go object and Mapping to C object.
func NewMesh(cVertexCount int32, cTriangleCount int32, cVertices []float32, cTexcoords []float32, cTexcoords2 []float32, cNormals []float32, cTangents []float32, cColors []byte, cIndices []uint16, cAnimVertices []float32, cAnimNormals []float32, cBoneIds []int32, cBoneWeights []float32, cVaoId uint32, cVboId []uint32) Mesh {
	obj := *new(gMesh)
	obj.gVertexCount = cVertexCount
	obj.gTriangleCount = cTriangleCount
	obj.gVertices = cVertices
	obj.gTexcoords = cTexcoords
	obj.gTexcoords2 = cTexcoords2
	obj.gNormals = cNormals
	obj.gTangents = cTangents
	obj.gColors = cColors
	obj.gIndices = cIndices
	obj.gAnimVertices = cAnimVertices
	obj.gAnimNormals = cAnimNormals
	obj.gBoneIds = cBoneIds
	obj.gBoneWeights = cBoneWeights
	obj.gVaoId = cVaoId
	obj.gVboId = cVboId

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocMesh.")
	}
	return *(*Mesh)(unsafe.Pointer(ret0))
}

// AllocMesh new Go object and Mapping to C object.
func AllocMesh(cVertexCount int32, cTriangleCount int32, cVertices []float32, cTexcoords []float32, cTexcoords2 []float32, cNormals []float32, cTangents []float32, cColors []byte, cIndices []uint16, cAnimVertices []float32, cAnimNormals []float32, cBoneIds []int32, cBoneWeights []float32, cVaoId uint32, cVboId []uint32) (*Mesh, *cgoAllocMap) {
	obj := *new(gMesh)
	obj.gVertexCount = cVertexCount
	obj.gTriangleCount = cTriangleCount
	obj.gVertices = cVertices
	obj.gTexcoords = cTexcoords
	obj.gTexcoords2 = cTexcoords2
	obj.gNormals = cNormals
	obj.gTangents = cTangents
	obj.gColors = cColors
	obj.gIndices = cIndices
	obj.gAnimVertices = cAnimVertices
	obj.gAnimNormals = cAnimNormals
	obj.gBoneIds = cBoneIds
	obj.gBoneWeights = cBoneWeights
	obj.gVaoId = cVaoId
	obj.gVboId = cVboId

	ret0, alloc0 := obj.passRef()
	ret1 := (*Mesh)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Mesh) Index(index int32) *Mesh {
	ptr1 := (*Mesh)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfMeshValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Mesh) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Mesh) {
			a.Free()
		})
	}
}

// Vertices returns a reference to C object within a struct
func (x *Mesh) Verticeser(index int32) *float32 {
	var ret *float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ptr0 := x.Vertices
	ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfPlainValue)))
	ret = (*float32)(unsafe.Pointer(ptr1))

	return ret
}

// Texcoords returns a reference to C object within a struct
func (x *Mesh) Texcoordser(index int32) *float32 {
	var ret *float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ptr0 := x.Texcoords
	ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfPlainValue)))
	ret = (*float32)(unsafe.Pointer(ptr1))

	return ret
}

// Texcoords2 returns a reference to C object within a struct
func (x *Mesh) Texcoords2er(index int32) *float32 {
	var ret *float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ptr0 := x.Texcoords2
	ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfPlainValue)))
	ret = (*float32)(unsafe.Pointer(ptr1))

	return ret
}

// Normals returns a reference to C object within a struct
func (x *Mesh) Normalser(index int32) *float32 {
	var ret *float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ptr0 := x.Normals
	ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfPlainValue)))
	ret = (*float32)(unsafe.Pointer(ptr1))

	return ret
}

// Tangents returns a reference to C object within a struct
func (x *Mesh) Tangentser(index int32) *float32 {
	var ret *float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ptr0 := x.Tangents
	ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfPlainValue)))
	ret = (*float32)(unsafe.Pointer(ptr1))

	return ret
}

// Colors returns a reference to C object within a struct
func (x *Mesh) Colorser(index int32) *byte {
	var ret *byte

	const sizeOfPlainValue = unsafe.Sizeof([1]C.uchar{})
	ptr0 := x.Colors
	ptr1 := (*C.uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfPlainValue)))
	ret = (*byte)(unsafe.Pointer(ptr1))

	return ret
}

// Indices returns a reference to C object within a struct
func (x *Mesh) Indiceser(index int32) *uint16 {
	var ret *uint16

	const sizeOfPlainValue = unsafe.Sizeof([1]C.ushort{})
	ptr0 := x.Indices
	ptr1 := (*C.ushort)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfPlainValue)))
	ret = (*uint16)(unsafe.Pointer(ptr1))

	return ret
}

// AnimVertices returns a reference to C object within a struct
func (x *Mesh) AnimVerticeser(index int32) *float32 {
	var ret *float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ptr0 := x.AnimVertices
	ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfPlainValue)))
	ret = (*float32)(unsafe.Pointer(ptr1))

	return ret
}

// AnimNormals returns a reference to C object within a struct
func (x *Mesh) AnimNormalser(index int32) *float32 {
	var ret *float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ptr0 := x.AnimNormals
	ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfPlainValue)))
	ret = (*float32)(unsafe.Pointer(ptr1))

	return ret
}

// BoneIds returns a reference to C object within a struct
func (x *Mesh) BoneIdser(index int32) *int32 {
	var ret *int32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.int{})
	ptr0 := x.BoneIds
	ptr1 := (*C.int)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfPlainValue)))
	ret = (*int32)(unsafe.Pointer(ptr1))

	return ret
}

// BoneWeights returns a reference to C object within a struct
func (x *Mesh) BoneWeightser(index int32) *float32 {
	var ret *float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ptr0 := x.BoneWeights
	ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfPlainValue)))
	ret = (*float32)(unsafe.Pointer(ptr1))

	return ret
}

// VboId returns a reference to C object within a struct
func (x *Mesh) VboIder(index int32) *uint32 {
	var ret *uint32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.uint{})
	ptr0 := x.VboId
	ptr1 := (*C.uint)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfPlainValue)))
	ret = (*uint32)(unsafe.Pointer(ptr1))

	return ret
}

// allocShaderMemory allocates memory for type C.Shader in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaderMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaderValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfShaderValue = unsafe.Sizeof([1]C.Shader{})

// newShaderRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newShaderRef(ref unsafe.Pointer) *gShader {
	if ref == nil {
		return nil
	}
	obj := new(gShader)
	obj.reff85f9b1e = (*C.Shader)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gShader) passRef() (*C.Shader, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff85f9b1e != nil {
		if x.allocsf85f9b1e != nil {
			return x.reff85f9b1e, x.allocsf85f9b1e.(*cgoAllocMap)
		} else {
			return x.reff85f9b1e, nil
		}
	}
	memf85f9b1e := unsafe.Pointer(new(C.Shader))
	reff85f9b1e := (*C.Shader)(memf85f9b1e)
	allocsf85f9b1e := new(cgoAllocMap)
	// allocsf85f9b1e.Add(memf85f9b1e)

	var cid_allocs *cgoAllocMap
	reff85f9b1e.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocsf85f9b1e.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var clocs_allocs *cgoAllocMap
	reff85f9b1e.locs, clocs_allocs = unpackSInt32(x.gLocs)
	allocsf85f9b1e.Borrow(clocs_allocs)
	x.gLocs = *new([]int32)

	x.reff85f9b1e = reff85f9b1e
	x.allocsf85f9b1e = allocsf85f9b1e

	return reff85f9b1e, allocsf85f9b1e
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gShader) passValue() (C.Shader, *cgoAllocMap) {
	if x.reff85f9b1e != nil {
		return *x.reff85f9b1e, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gShader) convert() *Shader {
	if x.reff85f9b1e != nil {
		return (*Shader)(unsafe.Pointer(x.reff85f9b1e))
	}
	x.passRef()
	return (*Shader)(unsafe.Pointer(x.reff85f9b1e))
}

// NewShader new Go object and Mapping to C object.
func NewShader(cId uint32, cLocs []int32) Shader {
	obj := *new(gShader)
	obj.gId = cId
	obj.gLocs = cLocs

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocShader.")
	}
	return *(*Shader)(unsafe.Pointer(ret0))
}

// AllocShader new Go object and Mapping to C object.
func AllocShader(cId uint32, cLocs []int32) (*Shader, *cgoAllocMap) {
	obj := *new(gShader)
	obj.gId = cId
	obj.gLocs = cLocs

	ret0, alloc0 := obj.passRef()
	ret1 := (*Shader)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Shader) Index(index int32) *Shader {
	ptr1 := (*Shader)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfShaderValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Shader) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Shader) {
			a.Free()
		})
	}
}

// Locs returns a reference to C object within a struct
func (x *Shader) Locser(index int32) *int32 {
	var ret *int32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.int{})
	ptr0 := x.Locs
	ptr1 := (*C.int)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfPlainValue)))
	ret = (*int32)(unsafe.Pointer(ptr1))

	return ret
}

// allocMaterialMapMemory allocates memory for type C.MaterialMap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMaterialMapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMaterialMapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMaterialMapValue = unsafe.Sizeof([1]C.MaterialMap{})

// newMaterialMapRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newMaterialMapRef(ref unsafe.Pointer) *gMaterialMap {
	if ref == nil {
		return nil
	}
	obj := new(gMaterialMap)
	obj.refa8350ad3 = (*C.MaterialMap)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gMaterialMap) passRef() (*C.MaterialMap, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa8350ad3 != nil {
		if x.allocsa8350ad3 != nil {
			return x.refa8350ad3, x.allocsa8350ad3.(*cgoAllocMap)
		} else {
			return x.refa8350ad3, nil
		}
	}
	mema8350ad3 := unsafe.Pointer(new(C.MaterialMap))
	refa8350ad3 := (*C.MaterialMap)(mema8350ad3)
	allocsa8350ad3 := new(cgoAllocMap)
	// allocsa8350ad3.Add(mema8350ad3)

	var ctexture_allocs *cgoAllocMap
	refa8350ad3.texture, ctexture_allocs = x.gTexture.passValue()
	allocsa8350ad3.Borrow(ctexture_allocs)
	x.gTexture = *new(gTexture2D)

	var ccolor_allocs *cgoAllocMap
	refa8350ad3.color, ccolor_allocs = x.gColor.passValue()
	allocsa8350ad3.Borrow(ccolor_allocs)
	x.gColor = *new(gColor)

	var cvalue_allocs *cgoAllocMap
	refa8350ad3.value, cvalue_allocs = (C.float)(x.gValue), cgoAllocsUnknown
	allocsa8350ad3.Borrow(cvalue_allocs)
	x.gValue = *new(float32)

	x.refa8350ad3 = refa8350ad3
	x.allocsa8350ad3 = allocsa8350ad3

	return refa8350ad3, allocsa8350ad3
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gMaterialMap) passValue() (C.MaterialMap, *cgoAllocMap) {
	if x.refa8350ad3 != nil {
		return *x.refa8350ad3, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gMaterialMap) convert() *MaterialMap {
	if x.refa8350ad3 != nil {
		return (*MaterialMap)(unsafe.Pointer(x.refa8350ad3))
	}
	x.passRef()
	return (*MaterialMap)(unsafe.Pointer(x.refa8350ad3))
}

// NewMaterialMap new Go object and Mapping to C object.
func NewMaterialMap(cTexture Texture2D, cColor Color, cValue float32) MaterialMap {
	obj := *new(gMaterialMap)
	obj.gTexture = *newTexture2DRef(unsafe.Pointer(&cTexture))
	obj.gColor = *newColorRef(unsafe.Pointer(&cColor))
	obj.gValue = cValue

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocMaterialMap.")
	}
	return *(*MaterialMap)(unsafe.Pointer(ret0))
}

// AllocMaterialMap new Go object and Mapping to C object.
func AllocMaterialMap(cTexture Texture2D, cColor Color, cValue float32) (*MaterialMap, *cgoAllocMap) {
	obj := *new(gMaterialMap)
	obj.gTexture = *newTexture2DRef(unsafe.Pointer(&cTexture))
	obj.gColor = *newColorRef(unsafe.Pointer(&cColor))
	obj.gValue = cValue

	ret0, alloc0 := obj.passRef()
	ret1 := (*MaterialMap)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *MaterialMap) Index(index int32) *MaterialMap {
	ptr1 := (*MaterialMap)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfMaterialMapValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *MaterialMap) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*MaterialMap) {
			a.Free()
		})
	}
}

// allocMaterialMemory allocates memory for type C.Material in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMaterialMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMaterialValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMaterialValue = unsafe.Sizeof([1]C.Material{})

// unpackSMaterialMap transforms a sliced Go data structure into plain C format.
func unpackSMaterialMap(x []gMaterialMap) (unpacked *C.MaterialMap, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.MaterialMap) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMaterialMapMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.MaterialMap)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].passValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.MaterialMap)(h.Data)
	return
}

// newMaterialRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newMaterialRef(ref unsafe.Pointer) *gMaterial {
	if ref == nil {
		return nil
	}
	obj := new(gMaterial)
	obj.ref85c817c3 = (*C.Material)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gMaterial) passRef() (*C.Material, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref85c817c3 != nil {
		if x.allocs85c817c3 != nil {
			return x.ref85c817c3, x.allocs85c817c3.(*cgoAllocMap)
		} else {
			return x.ref85c817c3, nil
		}
	}
	mem85c817c3 := unsafe.Pointer(new(C.Material))
	ref85c817c3 := (*C.Material)(mem85c817c3)
	allocs85c817c3 := new(cgoAllocMap)
	// allocs85c817c3.Add(mem85c817c3)

	var cshader_allocs *cgoAllocMap
	ref85c817c3.shader, cshader_allocs = x.gShader.passValue()
	allocs85c817c3.Borrow(cshader_allocs)
	x.gShader = *new(gShader)

	var cmaps_allocs *cgoAllocMap
	ref85c817c3.maps, cmaps_allocs = unpackSMaterialMap(x.gMaps)
	allocs85c817c3.Borrow(cmaps_allocs)
	x.gMaps = *new([]gMaterialMap)

	var cparams_allocs *cgoAllocMap
	ref85c817c3.params, cparams_allocs = unpackSFloat32(x.gParams)
	allocs85c817c3.Borrow(cparams_allocs)
	x.gParams = *new([]float32)

	x.ref85c817c3 = ref85c817c3
	x.allocs85c817c3 = allocs85c817c3

	return ref85c817c3, allocs85c817c3
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gMaterial) passValue() (C.Material, *cgoAllocMap) {
	if x.ref85c817c3 != nil {
		return *x.ref85c817c3, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gMaterial) convert() *Material {
	if x.ref85c817c3 != nil {
		return (*Material)(unsafe.Pointer(x.ref85c817c3))
	}
	x.passRef()
	return (*Material)(unsafe.Pointer(x.ref85c817c3))
}

// NewMaterial new Go object and Mapping to C object.
func NewMaterial(cShader Shader, cMaps []MaterialMap, cParams []float32) Material {
	obj := *new(gMaterial)
	obj.gShader = *newShaderRef(unsafe.Pointer(&cShader))

	var maps0 []gMaterialMap
	for i0 := range cMaps {
		p0 := *newMaterialMapRef(unsafe.Pointer(&cMaps[i0]))
		maps0 = append(maps0, p0)
	}
	obj.gMaps = maps0
	obj.gParams = cParams

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocMaterial.")
	}
	return *(*Material)(unsafe.Pointer(ret0))
}

// AllocMaterial new Go object and Mapping to C object.
func AllocMaterial(cShader Shader, cMaps []MaterialMap, cParams []float32) (*Material, *cgoAllocMap) {
	obj := *new(gMaterial)
	obj.gShader = *newShaderRef(unsafe.Pointer(&cShader))

	var maps0 []gMaterialMap
	for i0 := range cMaps {
		p0 := *newMaterialMapRef(unsafe.Pointer(&cMaps[i0]))
		maps0 = append(maps0, p0)
	}
	obj.gMaps = maps0
	obj.gParams = cParams

	ret0, alloc0 := obj.passRef()
	ret1 := (*Material)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Material) Index(index int32) *Material {
	ptr1 := (*Material)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfMaterialValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Material) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Material) {
			a.Free()
		})
	}
}

// Maps returns a reference to C object within a struct
func (x *Material) Mapser(index int32) *MaterialMap {
	var ret *MaterialMap

	ptr0 := x.Maps
	ptr1 := (*C.MaterialMap)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfMaterialMapValue)))
	ret = newMaterialMapRef(unsafe.Pointer(ptr1)).convert()

	return ret
}

// Params returns a reference to C object within a struct
func (x *Material) Paramser(index int32) *float32 {
	var ret *float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ptr0 := x.Params
	ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfPlainValue)))
	ret = (*float32)(unsafe.Pointer(ptr1))

	return ret
}

// allocTransformMemory allocates memory for type C.Transform in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTransformMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTransformValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTransformValue = unsafe.Sizeof([1]C.Transform{})

// newTransformRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newTransformRef(ref unsafe.Pointer) *gTransform {
	if ref == nil {
		return nil
	}
	obj := new(gTransform)
	obj.reff543030e = (*C.Transform)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gTransform) passRef() (*C.Transform, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff543030e != nil {
		if x.allocsf543030e != nil {
			return x.reff543030e, x.allocsf543030e.(*cgoAllocMap)
		} else {
			return x.reff543030e, nil
		}
	}
	memf543030e := unsafe.Pointer(new(C.Transform))
	reff543030e := (*C.Transform)(memf543030e)
	allocsf543030e := new(cgoAllocMap)
	// allocsf543030e.Add(memf543030e)

	var ctranslation_allocs *cgoAllocMap
	reff543030e.translation, ctranslation_allocs = x.gTranslation.passValue()
	allocsf543030e.Borrow(ctranslation_allocs)
	x.gTranslation = *new(gVector3)

	var crotation_allocs *cgoAllocMap
	reff543030e.rotation, crotation_allocs = x.gRotation.passValue()
	allocsf543030e.Borrow(crotation_allocs)
	x.gRotation = *new(gQuaternion)

	var cscale_allocs *cgoAllocMap
	reff543030e.scale, cscale_allocs = x.gScale.passValue()
	allocsf543030e.Borrow(cscale_allocs)
	x.gScale = *new(gVector3)

	x.reff543030e = reff543030e
	x.allocsf543030e = allocsf543030e

	return reff543030e, allocsf543030e
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gTransform) passValue() (C.Transform, *cgoAllocMap) {
	if x.reff543030e != nil {
		return *x.reff543030e, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gTransform) convert() *Transform {
	if x.reff543030e != nil {
		return (*Transform)(unsafe.Pointer(x.reff543030e))
	}
	x.passRef()
	return (*Transform)(unsafe.Pointer(x.reff543030e))
}

// NewTransform new Go object and Mapping to C object.
func NewTransform(cTranslation Vector3, cRotation Quaternion, cScale Vector3) Transform {
	obj := *new(gTransform)
	obj.gTranslation = *newVector3Ref(unsafe.Pointer(&cTranslation))
	obj.gRotation = *newQuaternionRef(unsafe.Pointer(&cRotation))
	obj.gScale = *newVector3Ref(unsafe.Pointer(&cScale))

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocTransform.")
	}
	return *(*Transform)(unsafe.Pointer(ret0))
}

// AllocTransform new Go object and Mapping to C object.
func AllocTransform(cTranslation Vector3, cRotation Quaternion, cScale Vector3) (*Transform, *cgoAllocMap) {
	obj := *new(gTransform)
	obj.gTranslation = *newVector3Ref(unsafe.Pointer(&cTranslation))
	obj.gRotation = *newQuaternionRef(unsafe.Pointer(&cRotation))
	obj.gScale = *newVector3Ref(unsafe.Pointer(&cScale))

	ret0, alloc0 := obj.passRef()
	ret1 := (*Transform)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Transform) Index(index int32) *Transform {
	ptr1 := (*Transform)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfTransformValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Transform) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Transform) {
			a.Free()
		})
	}
}

// allocBoneInfoMemory allocates memory for type C.BoneInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBoneInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBoneInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBoneInfoValue = unsafe.Sizeof([1]C.BoneInfo{})

// newBoneInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newBoneInfoRef(ref unsafe.Pointer) *gBoneInfo {
	if ref == nil {
		return nil
	}
	obj := new(gBoneInfo)
	obj.ref5ab7f197 = (*C.BoneInfo)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gBoneInfo) passRef() (*C.BoneInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ab7f197 != nil {
		if x.allocs5ab7f197 != nil {
			return x.ref5ab7f197, x.allocs5ab7f197.(*cgoAllocMap)
		} else {
			return x.ref5ab7f197, nil
		}
	}
	mem5ab7f197 := unsafe.Pointer(new(C.BoneInfo))
	ref5ab7f197 := (*C.BoneInfo)(mem5ab7f197)
	allocs5ab7f197 := new(cgoAllocMap)
	// allocs5ab7f197.Add(mem5ab7f197)

	var cname_allocs *cgoAllocMap
	ref5ab7f197.name, cname_allocs = *(*[32]C.char)(unsafe.Pointer(&x.gName)), cgoAllocsUnknown
	allocs5ab7f197.Borrow(cname_allocs)
	x.gName = *new([32]byte)

	var cparent_allocs *cgoAllocMap
	ref5ab7f197.parent, cparent_allocs = (C.int)(x.gParent), cgoAllocsUnknown
	allocs5ab7f197.Borrow(cparent_allocs)
	x.gParent = *new(int32)

	x.ref5ab7f197 = ref5ab7f197
	x.allocs5ab7f197 = allocs5ab7f197

	return ref5ab7f197, allocs5ab7f197
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gBoneInfo) passValue() (C.BoneInfo, *cgoAllocMap) {
	if x.ref5ab7f197 != nil {
		return *x.ref5ab7f197, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gBoneInfo) convert() *BoneInfo {
	if x.ref5ab7f197 != nil {
		return (*BoneInfo)(unsafe.Pointer(x.ref5ab7f197))
	}
	x.passRef()
	return (*BoneInfo)(unsafe.Pointer(x.ref5ab7f197))
}

// NewBoneInfo new Go object and Mapping to C object.
func NewBoneInfo(cName [32]byte, cParent int32) BoneInfo {
	obj := *new(gBoneInfo)
	obj.gName = cName
	obj.gParent = cParent

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocBoneInfo.")
	}
	return *(*BoneInfo)(unsafe.Pointer(ret0))
}

// AllocBoneInfo new Go object and Mapping to C object.
func AllocBoneInfo(cName [32]byte, cParent int32) (*BoneInfo, *cgoAllocMap) {
	obj := *new(gBoneInfo)
	obj.gName = cName
	obj.gParent = cParent

	ret0, alloc0 := obj.passRef()
	ret1 := (*BoneInfo)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *BoneInfo) Index(index int32) *BoneInfo {
	ptr1 := (*BoneInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfBoneInfoValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *BoneInfo) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*BoneInfo) {
			a.Free()
		})
	}
}

// Name returns a reference to C object within a struct

// allocModelMemory allocates memory for type C.Model in C.
// The caller is responsible for freeing the this memory via C.free.
func allocModelMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfModelValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfModelValue = unsafe.Sizeof([1]C.Model{})

// unpackSMesh transforms a sliced Go data structure into plain C format.
func unpackSMesh(x []gMesh) (unpacked *C.Mesh, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Mesh) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMeshMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Mesh)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].passValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Mesh)(h.Data)
	return
}

// unpackSMaterial transforms a sliced Go data structure into plain C format.
func unpackSMaterial(x []gMaterial) (unpacked *C.Material, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Material) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMaterialMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Material)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].passValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Material)(h.Data)
	return
}

// unpackSBoneInfo transforms a sliced Go data structure into plain C format.
func unpackSBoneInfo(x []gBoneInfo) (unpacked *C.BoneInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.BoneInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBoneInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.BoneInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].passValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.BoneInfo)(h.Data)
	return
}

// unpackSTransform transforms a sliced Go data structure into plain C format.
func unpackSTransform(x []gTransform) (unpacked *C.Transform, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Transform) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocTransformMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Transform)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].passValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Transform)(h.Data)
	return
}

// newModelRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newModelRef(ref unsafe.Pointer) *gModel {
	if ref == nil {
		return nil
	}
	obj := new(gModel)
	obj.ref16545ddd = (*C.Model)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gModel) passRef() (*C.Model, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref16545ddd != nil {
		if x.allocs16545ddd != nil {
			return x.ref16545ddd, x.allocs16545ddd.(*cgoAllocMap)
		} else {
			return x.ref16545ddd, nil
		}
	}
	mem16545ddd := unsafe.Pointer(new(C.Model))
	ref16545ddd := (*C.Model)(mem16545ddd)
	allocs16545ddd := new(cgoAllocMap)
	// allocs16545ddd.Add(mem16545ddd)

	var ctransform_allocs *cgoAllocMap
	ref16545ddd.transform, ctransform_allocs = x.gTransform.passValue()
	allocs16545ddd.Borrow(ctransform_allocs)
	x.gTransform = *new(gMatrix)

	var cmeshCount_allocs *cgoAllocMap
	ref16545ddd.meshCount, cmeshCount_allocs = (C.int)(x.gMeshCount), cgoAllocsUnknown
	allocs16545ddd.Borrow(cmeshCount_allocs)
	x.gMeshCount = *new(int32)

	var cmaterialCount_allocs *cgoAllocMap
	ref16545ddd.materialCount, cmaterialCount_allocs = (C.int)(x.gMaterialCount), cgoAllocsUnknown
	allocs16545ddd.Borrow(cmaterialCount_allocs)
	x.gMaterialCount = *new(int32)

	var cmeshes_allocs *cgoAllocMap
	ref16545ddd.meshes, cmeshes_allocs = unpackSMesh(x.gMeshes)
	allocs16545ddd.Borrow(cmeshes_allocs)
	x.gMeshes = *new([]gMesh)

	var cmaterials_allocs *cgoAllocMap
	ref16545ddd.materials, cmaterials_allocs = unpackSMaterial(x.gMaterials)
	allocs16545ddd.Borrow(cmaterials_allocs)
	x.gMaterials = *new([]gMaterial)

	var cmeshMaterial_allocs *cgoAllocMap
	ref16545ddd.meshMaterial, cmeshMaterial_allocs = unpackSInt32(x.gMeshMaterial)
	allocs16545ddd.Borrow(cmeshMaterial_allocs)
	x.gMeshMaterial = *new([]int32)

	var cboneCount_allocs *cgoAllocMap
	ref16545ddd.boneCount, cboneCount_allocs = (C.int)(x.gBoneCount), cgoAllocsUnknown
	allocs16545ddd.Borrow(cboneCount_allocs)
	x.gBoneCount = *new(int32)

	var cbones_allocs *cgoAllocMap
	ref16545ddd.bones, cbones_allocs = unpackSBoneInfo(x.gBones)
	allocs16545ddd.Borrow(cbones_allocs)
	x.gBones = *new([]gBoneInfo)

	var cbindPose_allocs *cgoAllocMap
	ref16545ddd.bindPose, cbindPose_allocs = unpackSTransform(x.gBindPose)
	allocs16545ddd.Borrow(cbindPose_allocs)
	x.gBindPose = *new([]gTransform)

	x.ref16545ddd = ref16545ddd
	x.allocs16545ddd = allocs16545ddd

	return ref16545ddd, allocs16545ddd
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gModel) passValue() (C.Model, *cgoAllocMap) {
	if x.ref16545ddd != nil {
		return *x.ref16545ddd, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gModel) convert() *Model {
	if x.ref16545ddd != nil {
		return (*Model)(unsafe.Pointer(x.ref16545ddd))
	}
	x.passRef()
	return (*Model)(unsafe.Pointer(x.ref16545ddd))
}

// NewModel new Go object and Mapping to C object.
func NewModel(cTransform Matrix, cMeshCount int32, cMaterialCount int32, cMeshes []Mesh, cMaterials []Material, cMeshMaterial []int32, cBoneCount int32, cBones []BoneInfo, cBindPose []Transform) Model {
	obj := *new(gModel)
	obj.gTransform = *newMatrixRef(unsafe.Pointer(&cTransform))
	obj.gMeshCount = cMeshCount
	obj.gMaterialCount = cMaterialCount

	var meshes0 []gMesh
	for i0 := range cMeshes {
		p0 := *newMeshRef(unsafe.Pointer(&cMeshes[i0]))
		meshes0 = append(meshes0, p0)
	}
	obj.gMeshes = meshes0

	var materials0 []gMaterial
	for i0 := range cMaterials {
		p0 := *newMaterialRef(unsafe.Pointer(&cMaterials[i0]))
		materials0 = append(materials0, p0)
	}
	obj.gMaterials = materials0
	obj.gMeshMaterial = cMeshMaterial
	obj.gBoneCount = cBoneCount

	var bones0 []gBoneInfo
	for i0 := range cBones {
		p0 := *newBoneInfoRef(unsafe.Pointer(&cBones[i0]))
		bones0 = append(bones0, p0)
	}
	obj.gBones = bones0

	var bindPose0 []gTransform
	for i0 := range cBindPose {
		p0 := *newTransformRef(unsafe.Pointer(&cBindPose[i0]))
		bindPose0 = append(bindPose0, p0)
	}
	obj.gBindPose = bindPose0

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocModel.")
	}
	return *(*Model)(unsafe.Pointer(ret0))
}

// AllocModel new Go object and Mapping to C object.
func AllocModel(cTransform Matrix, cMeshCount int32, cMaterialCount int32, cMeshes []Mesh, cMaterials []Material, cMeshMaterial []int32, cBoneCount int32, cBones []BoneInfo, cBindPose []Transform) (*Model, *cgoAllocMap) {
	obj := *new(gModel)
	obj.gTransform = *newMatrixRef(unsafe.Pointer(&cTransform))
	obj.gMeshCount = cMeshCount
	obj.gMaterialCount = cMaterialCount

	var meshes0 []gMesh
	for i0 := range cMeshes {
		p0 := *newMeshRef(unsafe.Pointer(&cMeshes[i0]))
		meshes0 = append(meshes0, p0)
	}
	obj.gMeshes = meshes0

	var materials0 []gMaterial
	for i0 := range cMaterials {
		p0 := *newMaterialRef(unsafe.Pointer(&cMaterials[i0]))
		materials0 = append(materials0, p0)
	}
	obj.gMaterials = materials0
	obj.gMeshMaterial = cMeshMaterial
	obj.gBoneCount = cBoneCount

	var bones0 []gBoneInfo
	for i0 := range cBones {
		p0 := *newBoneInfoRef(unsafe.Pointer(&cBones[i0]))
		bones0 = append(bones0, p0)
	}
	obj.gBones = bones0

	var bindPose0 []gTransform
	for i0 := range cBindPose {
		p0 := *newTransformRef(unsafe.Pointer(&cBindPose[i0]))
		bindPose0 = append(bindPose0, p0)
	}
	obj.gBindPose = bindPose0

	ret0, alloc0 := obj.passRef()
	ret1 := (*Model)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Model) Index(index int32) *Model {
	ptr1 := (*Model)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfModelValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Model) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Model) {
			a.Free()
		})
	}
}

// Meshes returns a reference to C object within a struct
func (x *Model) Mesheser(index int32) *Mesh {
	var ret *Mesh

	ptr0 := x.Meshes
	ptr1 := (*C.Mesh)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfMeshValue)))
	ret = newMeshRef(unsafe.Pointer(ptr1)).convert()

	return ret
}

// Materials returns a reference to C object within a struct
func (x *Model) Materialser(index int32) *Material {
	var ret *Material

	ptr0 := x.Materials
	ptr1 := (*C.Material)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfMaterialValue)))
	ret = newMaterialRef(unsafe.Pointer(ptr1)).convert()

	return ret
}

// MeshMaterial returns a reference to C object within a struct
func (x *Model) MeshMaterialer(index int32) *int32 {
	var ret *int32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.int{})
	ptr0 := x.MeshMaterial
	ptr1 := (*C.int)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfPlainValue)))
	ret = (*int32)(unsafe.Pointer(ptr1))

	return ret
}

// Bones returns a reference to C object within a struct
func (x *Model) Boneser(index int32) *BoneInfo {
	var ret *BoneInfo

	ptr0 := x.Bones
	ptr1 := (*C.BoneInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfBoneInfoValue)))
	ret = newBoneInfoRef(unsafe.Pointer(ptr1)).convert()

	return ret
}

// BindPose returns a reference to C object within a struct
func (x *Model) BindPoseer(index int32) *Transform {
	var ret *Transform

	ptr0 := x.BindPose
	ptr1 := (*C.Transform)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfTransformValue)))
	ret = newTransformRef(unsafe.Pointer(ptr1)).convert()

	return ret
}

// allocModelAnimationMemory allocates memory for type C.ModelAnimation in C.
// The caller is responsible for freeing the this memory via C.free.
func allocModelAnimationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfModelAnimationValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfModelAnimationValue = unsafe.Sizeof([1]C.ModelAnimation{})

// allocPTransformMemory allocates memory for type *C.Transform in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTransformMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTransformValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPTransformValue = unsafe.Sizeof([1]*C.Transform{})

// unpackSSTransform transforms a sliced Go data structure into plain C format.
func unpackSSTransform(x [][]gTransform) (unpacked **C.Transform, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.Transform) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPTransformMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.Transform)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTransformMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.Transform)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].passValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.Transform)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.Transform)(h.Data)
	return
}

// newModelAnimationRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newModelAnimationRef(ref unsafe.Pointer) *gModelAnimation {
	if ref == nil {
		return nil
	}
	obj := new(gModelAnimation)
	obj.ref26dd6a24 = (*C.ModelAnimation)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gModelAnimation) passRef() (*C.ModelAnimation, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref26dd6a24 != nil {
		if x.allocs26dd6a24 != nil {
			return x.ref26dd6a24, x.allocs26dd6a24.(*cgoAllocMap)
		} else {
			return x.ref26dd6a24, nil
		}
	}
	mem26dd6a24 := unsafe.Pointer(new(C.ModelAnimation))
	ref26dd6a24 := (*C.ModelAnimation)(mem26dd6a24)
	allocs26dd6a24 := new(cgoAllocMap)
	// allocs26dd6a24.Add(mem26dd6a24)

	var cboneCount_allocs *cgoAllocMap
	ref26dd6a24.boneCount, cboneCount_allocs = (C.int)(x.gBoneCount), cgoAllocsUnknown
	allocs26dd6a24.Borrow(cboneCount_allocs)
	x.gBoneCount = *new(int32)

	var cframeCount_allocs *cgoAllocMap
	ref26dd6a24.frameCount, cframeCount_allocs = (C.int)(x.gFrameCount), cgoAllocsUnknown
	allocs26dd6a24.Borrow(cframeCount_allocs)
	x.gFrameCount = *new(int32)

	var cbones_allocs *cgoAllocMap
	ref26dd6a24.bones, cbones_allocs = unpackSBoneInfo(x.gBones)
	allocs26dd6a24.Borrow(cbones_allocs)
	x.gBones = *new([]gBoneInfo)

	var cframePoses_allocs *cgoAllocMap
	ref26dd6a24.framePoses, cframePoses_allocs = unpackSSTransform(x.gFramePoses)
	allocs26dd6a24.Borrow(cframePoses_allocs)
	x.gFramePoses = *new([][]gTransform)

	x.ref26dd6a24 = ref26dd6a24
	x.allocs26dd6a24 = allocs26dd6a24

	return ref26dd6a24, allocs26dd6a24
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gModelAnimation) passValue() (C.ModelAnimation, *cgoAllocMap) {
	if x.ref26dd6a24 != nil {
		return *x.ref26dd6a24, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gModelAnimation) convert() *ModelAnimation {
	if x.ref26dd6a24 != nil {
		return (*ModelAnimation)(unsafe.Pointer(x.ref26dd6a24))
	}
	x.passRef()
	return (*ModelAnimation)(unsafe.Pointer(x.ref26dd6a24))
}

// NewModelAnimation new Go object and Mapping to C object.
func NewModelAnimation(cBoneCount int32, cFrameCount int32, cBones []BoneInfo, cFramePoses [][]Transform) ModelAnimation {
	obj := *new(gModelAnimation)
	obj.gBoneCount = cBoneCount
	obj.gFrameCount = cFrameCount

	var bones0 []gBoneInfo
	for i0 := range cBones {
		p0 := *newBoneInfoRef(unsafe.Pointer(&cBones[i0]))
		bones0 = append(bones0, p0)
	}
	obj.gBones = bones0

	var framePoses0 [][]gTransform
	for i0, v0 := range cFramePoses {
		s0 := make([]gTransform, len(v0))
		for i1 := range v0 {
			p0 := *newTransformRef(unsafe.Pointer(&cFramePoses[i0][i1]))
			s0 = append(s0, p0)
		}
		framePoses0 = append(framePoses0, s0)
	}
	obj.gFramePoses = framePoses0

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocModelAnimation.")
	}
	return *(*ModelAnimation)(unsafe.Pointer(ret0))
}

// AllocModelAnimation new Go object and Mapping to C object.
func AllocModelAnimation(cBoneCount int32, cFrameCount int32, cBones []BoneInfo, cFramePoses [][]Transform) (*ModelAnimation, *cgoAllocMap) {
	obj := *new(gModelAnimation)
	obj.gBoneCount = cBoneCount
	obj.gFrameCount = cFrameCount

	var bones0 []gBoneInfo
	for i0 := range cBones {
		p0 := *newBoneInfoRef(unsafe.Pointer(&cBones[i0]))
		bones0 = append(bones0, p0)
	}
	obj.gBones = bones0

	var framePoses0 [][]gTransform
	for i0, v0 := range cFramePoses {
		s0 := make([]gTransform, len(v0))
		for i1 := range v0 {
			p0 := *newTransformRef(unsafe.Pointer(&cFramePoses[i0][i1]))
			s0 = append(s0, p0)
		}
		framePoses0 = append(framePoses0, s0)
	}
	obj.gFramePoses = framePoses0

	ret0, alloc0 := obj.passRef()
	ret1 := (*ModelAnimation)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *ModelAnimation) Index(index int32) *ModelAnimation {
	ptr1 := (*ModelAnimation)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfModelAnimationValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *ModelAnimation) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*ModelAnimation) {
			a.Free()
		})
	}
}

// Bones returns a reference to C object within a struct
func (x *ModelAnimation) Boneser(index int32) *BoneInfo {
	var ret *BoneInfo

	ptr0 := x.Bones
	ptr1 := (*C.BoneInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfBoneInfoValue)))
	ret = newBoneInfoRef(unsafe.Pointer(ptr1)).convert()

	return ret
}

// FramePoses returns a reference to C object within a struct
func (x *ModelAnimation) FramePoseser(row int32, column int32) *Transform {
	var ret *Transform

	ptr0 := x.FramePoses
	ptr1 := (**C.Transform)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(row)*uintptr(sizeOfPtr)))
	ptr2 := (*C.Transform)(unsafe.Pointer(uintptr(unsafe.Pointer(*ptr1)) + uintptr(column)*uintptr(sizeOfTransformValue)))
	ret = newTransformRef(unsafe.Pointer(ptr2)).convert()

	return ret
}

// allocRayMemory allocates memory for type C.Ray in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRayMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRayValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRayValue = unsafe.Sizeof([1]C.Ray{})

// newRayRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newRayRef(ref unsafe.Pointer) *gRay {
	if ref == nil {
		return nil
	}
	obj := new(gRay)
	obj.refc546b0b2 = (*C.Ray)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gRay) passRef() (*C.Ray, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc546b0b2 != nil {
		if x.allocsc546b0b2 != nil {
			return x.refc546b0b2, x.allocsc546b0b2.(*cgoAllocMap)
		} else {
			return x.refc546b0b2, nil
		}
	}
	memc546b0b2 := unsafe.Pointer(new(C.Ray))
	refc546b0b2 := (*C.Ray)(memc546b0b2)
	allocsc546b0b2 := new(cgoAllocMap)
	// allocsc546b0b2.Add(memc546b0b2)

	var cposition_allocs *cgoAllocMap
	refc546b0b2.position, cposition_allocs = x.gPosition.passValue()
	allocsc546b0b2.Borrow(cposition_allocs)
	x.gPosition = *new(gVector3)

	var cdirection_allocs *cgoAllocMap
	refc546b0b2.direction, cdirection_allocs = x.gDirection.passValue()
	allocsc546b0b2.Borrow(cdirection_allocs)
	x.gDirection = *new(gVector3)

	x.refc546b0b2 = refc546b0b2
	x.allocsc546b0b2 = allocsc546b0b2

	return refc546b0b2, allocsc546b0b2
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gRay) passValue() (C.Ray, *cgoAllocMap) {
	if x.refc546b0b2 != nil {
		return *x.refc546b0b2, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gRay) convert() *Ray {
	if x.refc546b0b2 != nil {
		return (*Ray)(unsafe.Pointer(x.refc546b0b2))
	}
	x.passRef()
	return (*Ray)(unsafe.Pointer(x.refc546b0b2))
}

// NewRay new Go object and Mapping to C object.
func NewRay(cPosition Vector3, cDirection Vector3) Ray {
	obj := *new(gRay)
	obj.gPosition = *newVector3Ref(unsafe.Pointer(&cPosition))
	obj.gDirection = *newVector3Ref(unsafe.Pointer(&cDirection))

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocRay.")
	}
	return *(*Ray)(unsafe.Pointer(ret0))
}

// AllocRay new Go object and Mapping to C object.
func AllocRay(cPosition Vector3, cDirection Vector3) (*Ray, *cgoAllocMap) {
	obj := *new(gRay)
	obj.gPosition = *newVector3Ref(unsafe.Pointer(&cPosition))
	obj.gDirection = *newVector3Ref(unsafe.Pointer(&cDirection))

	ret0, alloc0 := obj.passRef()
	ret1 := (*Ray)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Ray) Index(index int32) *Ray {
	ptr1 := (*Ray)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfRayValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Ray) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Ray) {
			a.Free()
		})
	}
}

// allocRayHitInfoMemory allocates memory for type C.RayHitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRayHitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRayHitInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRayHitInfoValue = unsafe.Sizeof([1]C.RayHitInfo{})

// newRayHitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newRayHitInfoRef(ref unsafe.Pointer) *gRayHitInfo {
	if ref == nil {
		return nil
	}
	obj := new(gRayHitInfo)
	obj.refb8de43a9 = (*C.RayHitInfo)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gRayHitInfo) passRef() (*C.RayHitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8de43a9 != nil {
		if x.allocsb8de43a9 != nil {
			return x.refb8de43a9, x.allocsb8de43a9.(*cgoAllocMap)
		} else {
			return x.refb8de43a9, nil
		}
	}
	memb8de43a9 := unsafe.Pointer(new(C.RayHitInfo))
	refb8de43a9 := (*C.RayHitInfo)(memb8de43a9)
	allocsb8de43a9 := new(cgoAllocMap)
	// allocsb8de43a9.Add(memb8de43a9)

	var chit_allocs *cgoAllocMap
	refb8de43a9.hit, chit_allocs = (C._Bool)(x.gHit), cgoAllocsUnknown
	allocsb8de43a9.Borrow(chit_allocs)
	x.gHit = *new(bool)

	var cdistance_allocs *cgoAllocMap
	refb8de43a9.distance, cdistance_allocs = (C.float)(x.gDistance), cgoAllocsUnknown
	allocsb8de43a9.Borrow(cdistance_allocs)
	x.gDistance = *new(float32)

	var cposition_allocs *cgoAllocMap
	refb8de43a9.position, cposition_allocs = x.gPosition.passValue()
	allocsb8de43a9.Borrow(cposition_allocs)
	x.gPosition = *new(gVector3)

	var cnormal_allocs *cgoAllocMap
	refb8de43a9.normal, cnormal_allocs = x.gNormal.passValue()
	allocsb8de43a9.Borrow(cnormal_allocs)
	x.gNormal = *new(gVector3)

	x.refb8de43a9 = refb8de43a9
	x.allocsb8de43a9 = allocsb8de43a9

	return refb8de43a9, allocsb8de43a9
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gRayHitInfo) passValue() (C.RayHitInfo, *cgoAllocMap) {
	if x.refb8de43a9 != nil {
		return *x.refb8de43a9, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gRayHitInfo) convert() *RayHitInfo {
	if x.refb8de43a9 != nil {
		return (*RayHitInfo)(unsafe.Pointer(x.refb8de43a9))
	}
	x.passRef()
	return (*RayHitInfo)(unsafe.Pointer(x.refb8de43a9))
}

// NewRayHitInfo new Go object and Mapping to C object.
func NewRayHitInfo(cHit bool, cDistance float32, cPosition Vector3, cNormal Vector3) RayHitInfo {
	obj := *new(gRayHitInfo)
	obj.gHit = cHit
	obj.gDistance = cDistance
	obj.gPosition = *newVector3Ref(unsafe.Pointer(&cPosition))
	obj.gNormal = *newVector3Ref(unsafe.Pointer(&cNormal))

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocRayHitInfo.")
	}
	return *(*RayHitInfo)(unsafe.Pointer(ret0))
}

// AllocRayHitInfo new Go object and Mapping to C object.
func AllocRayHitInfo(cHit bool, cDistance float32, cPosition Vector3, cNormal Vector3) (*RayHitInfo, *cgoAllocMap) {
	obj := *new(gRayHitInfo)
	obj.gHit = cHit
	obj.gDistance = cDistance
	obj.gPosition = *newVector3Ref(unsafe.Pointer(&cPosition))
	obj.gNormal = *newVector3Ref(unsafe.Pointer(&cNormal))

	ret0, alloc0 := obj.passRef()
	ret1 := (*RayHitInfo)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *RayHitInfo) Index(index int32) *RayHitInfo {
	ptr1 := (*RayHitInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfRayHitInfoValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *RayHitInfo) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*RayHitInfo) {
			a.Free()
		})
	}
}

// allocBoundingBoxMemory allocates memory for type C.BoundingBox in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBoundingBoxMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBoundingBoxValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBoundingBoxValue = unsafe.Sizeof([1]C.BoundingBox{})

// newBoundingBoxRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newBoundingBoxRef(ref unsafe.Pointer) *gBoundingBox {
	if ref == nil {
		return nil
	}
	obj := new(gBoundingBox)
	obj.refa54e9d16 = (*C.BoundingBox)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gBoundingBox) passRef() (*C.BoundingBox, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa54e9d16 != nil {
		if x.allocsa54e9d16 != nil {
			return x.refa54e9d16, x.allocsa54e9d16.(*cgoAllocMap)
		} else {
			return x.refa54e9d16, nil
		}
	}
	mema54e9d16 := unsafe.Pointer(new(C.BoundingBox))
	refa54e9d16 := (*C.BoundingBox)(mema54e9d16)
	allocsa54e9d16 := new(cgoAllocMap)
	// allocsa54e9d16.Add(mema54e9d16)

	var cmin_allocs *cgoAllocMap
	refa54e9d16.min, cmin_allocs = x.gMin.passValue()
	allocsa54e9d16.Borrow(cmin_allocs)
	x.gMin = *new(gVector3)

	var cmax_allocs *cgoAllocMap
	refa54e9d16.max, cmax_allocs = x.gMax.passValue()
	allocsa54e9d16.Borrow(cmax_allocs)
	x.gMax = *new(gVector3)

	x.refa54e9d16 = refa54e9d16
	x.allocsa54e9d16 = allocsa54e9d16

	return refa54e9d16, allocsa54e9d16
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gBoundingBox) passValue() (C.BoundingBox, *cgoAllocMap) {
	if x.refa54e9d16 != nil {
		return *x.refa54e9d16, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gBoundingBox) convert() *BoundingBox {
	if x.refa54e9d16 != nil {
		return (*BoundingBox)(unsafe.Pointer(x.refa54e9d16))
	}
	x.passRef()
	return (*BoundingBox)(unsafe.Pointer(x.refa54e9d16))
}

// NewBoundingBox new Go object and Mapping to C object.
func NewBoundingBox(cMin Vector3, cMax Vector3) BoundingBox {
	obj := *new(gBoundingBox)
	obj.gMin = *newVector3Ref(unsafe.Pointer(&cMin))
	obj.gMax = *newVector3Ref(unsafe.Pointer(&cMax))

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocBoundingBox.")
	}
	return *(*BoundingBox)(unsafe.Pointer(ret0))
}

// AllocBoundingBox new Go object and Mapping to C object.
func AllocBoundingBox(cMin Vector3, cMax Vector3) (*BoundingBox, *cgoAllocMap) {
	obj := *new(gBoundingBox)
	obj.gMin = *newVector3Ref(unsafe.Pointer(&cMin))
	obj.gMax = *newVector3Ref(unsafe.Pointer(&cMax))

	ret0, alloc0 := obj.passRef()
	ret1 := (*BoundingBox)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *BoundingBox) Index(index int32) *BoundingBox {
	ptr1 := (*BoundingBox)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfBoundingBoxValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *BoundingBox) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*BoundingBox) {
			a.Free()
		})
	}
}

// allocWaveMemory allocates memory for type C.Wave in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWaveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWaveValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfWaveValue = unsafe.Sizeof([1]C.Wave{})

// newWaveRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newWaveRef(ref unsafe.Pointer) *gWave {
	if ref == nil {
		return nil
	}
	obj := new(gWave)
	obj.ref7a3602b7 = (*C.Wave)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gWave) passRef() (*C.Wave, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7a3602b7 != nil {
		if x.allocs7a3602b7 != nil {
			return x.ref7a3602b7, x.allocs7a3602b7.(*cgoAllocMap)
		} else {
			return x.ref7a3602b7, nil
		}
	}
	mem7a3602b7 := unsafe.Pointer(new(C.Wave))
	ref7a3602b7 := (*C.Wave)(mem7a3602b7)
	allocs7a3602b7 := new(cgoAllocMap)
	// allocs7a3602b7.Add(mem7a3602b7)

	var csampleCount_allocs *cgoAllocMap
	ref7a3602b7.sampleCount, csampleCount_allocs = (C.uint)(x.gSampleCount), cgoAllocsUnknown
	allocs7a3602b7.Borrow(csampleCount_allocs)
	x.gSampleCount = *new(uint32)

	var csampleRate_allocs *cgoAllocMap
	ref7a3602b7.sampleRate, csampleRate_allocs = (C.uint)(x.gSampleRate), cgoAllocsUnknown
	allocs7a3602b7.Borrow(csampleRate_allocs)
	x.gSampleRate = *new(uint32)

	var csampleSize_allocs *cgoAllocMap
	ref7a3602b7.sampleSize, csampleSize_allocs = (C.uint)(x.gSampleSize), cgoAllocsUnknown
	allocs7a3602b7.Borrow(csampleSize_allocs)
	x.gSampleSize = *new(uint32)

	var cchannels_allocs *cgoAllocMap
	ref7a3602b7.channels, cchannels_allocs = (C.uint)(x.gChannels), cgoAllocsUnknown
	allocs7a3602b7.Borrow(cchannels_allocs)
	x.gChannels = *new(uint32)

	var cdata_allocs *cgoAllocMap
	ref7a3602b7.data, cdata_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.gData)), cgoAllocsUnknown
	allocs7a3602b7.Borrow(cdata_allocs)
	x.gData = *new(unsafe.Pointer)

	x.ref7a3602b7 = ref7a3602b7
	x.allocs7a3602b7 = allocs7a3602b7

	return ref7a3602b7, allocs7a3602b7
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gWave) passValue() (C.Wave, *cgoAllocMap) {
	if x.ref7a3602b7 != nil {
		return *x.ref7a3602b7, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gWave) convert() *Wave {
	if x.ref7a3602b7 != nil {
		return (*Wave)(unsafe.Pointer(x.ref7a3602b7))
	}
	x.passRef()
	return (*Wave)(unsafe.Pointer(x.ref7a3602b7))
}

// NewWave new Go object and Mapping to C object.
func NewWave(cSampleCount uint32, cSampleRate uint32, cSampleSize uint32, cChannels uint32, cData unsafe.Pointer) Wave {
	obj := *new(gWave)
	obj.gSampleCount = cSampleCount
	obj.gSampleRate = cSampleRate
	obj.gSampleSize = cSampleSize
	obj.gChannels = cChannels
	obj.gData = cData

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocWave.")
	}
	return *(*Wave)(unsafe.Pointer(ret0))
}

// AllocWave new Go object and Mapping to C object.
func AllocWave(cSampleCount uint32, cSampleRate uint32, cSampleSize uint32, cChannels uint32, cData unsafe.Pointer) (*Wave, *cgoAllocMap) {
	obj := *new(gWave)
	obj.gSampleCount = cSampleCount
	obj.gSampleRate = cSampleRate
	obj.gSampleSize = cSampleSize
	obj.gChannels = cChannels
	obj.gData = cData

	ret0, alloc0 := obj.passRef()
	ret1 := (*Wave)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Wave) Index(index int32) *Wave {
	ptr1 := (*Wave)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfWaveValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Wave) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Wave) {
			a.Free()
		})
	}
}

// allocAudioStreamMemory allocates memory for type C.AudioStream in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAudioStreamMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAudioStreamValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAudioStreamValue = unsafe.Sizeof([1]C.AudioStream{})

// newAudioStreamRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newAudioStreamRef(ref unsafe.Pointer) *gAudioStream {
	if ref == nil {
		return nil
	}
	obj := new(gAudioStream)
	obj.ref997374a2 = (*C.AudioStream)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gAudioStream) passRef() (*C.AudioStream, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref997374a2 != nil {
		if x.allocs997374a2 != nil {
			return x.ref997374a2, x.allocs997374a2.(*cgoAllocMap)
		} else {
			return x.ref997374a2, nil
		}
	}
	mem997374a2 := unsafe.Pointer(new(C.AudioStream))
	ref997374a2 := (*C.AudioStream)(mem997374a2)
	allocs997374a2 := new(cgoAllocMap)
	// allocs997374a2.Add(mem997374a2)

	var csampleRate_allocs *cgoAllocMap
	ref997374a2.sampleRate, csampleRate_allocs = (C.uint)(x.gSampleRate), cgoAllocsUnknown
	allocs997374a2.Borrow(csampleRate_allocs)
	x.gSampleRate = *new(uint32)

	var csampleSize_allocs *cgoAllocMap
	ref997374a2.sampleSize, csampleSize_allocs = (C.uint)(x.gSampleSize), cgoAllocsUnknown
	allocs997374a2.Borrow(csampleSize_allocs)
	x.gSampleSize = *new(uint32)

	var cchannels_allocs *cgoAllocMap
	ref997374a2.channels, cchannels_allocs = (C.uint)(x.gChannels), cgoAllocsUnknown
	allocs997374a2.Borrow(cchannels_allocs)
	x.gChannels = *new(uint32)

	x.ref997374a2 = ref997374a2
	x.allocs997374a2 = allocs997374a2

	return ref997374a2, allocs997374a2
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gAudioStream) passValue() (C.AudioStream, *cgoAllocMap) {
	if x.ref997374a2 != nil {
		return *x.ref997374a2, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gAudioStream) convert() *AudioStream {
	if x.ref997374a2 != nil {
		return (*AudioStream)(unsafe.Pointer(x.ref997374a2))
	}
	x.passRef()
	return (*AudioStream)(unsafe.Pointer(x.ref997374a2))
}

// NewAudioStream new Go object and Mapping to C object.
func NewAudioStream(cSampleRate uint32, cSampleSize uint32, cChannels uint32) AudioStream {
	obj := *new(gAudioStream)
	obj.gSampleRate = cSampleRate
	obj.gSampleSize = cSampleSize
	obj.gChannels = cChannels

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocAudioStream.")
	}
	return *(*AudioStream)(unsafe.Pointer(ret0))
}

// AllocAudioStream new Go object and Mapping to C object.
func AllocAudioStream(cSampleRate uint32, cSampleSize uint32, cChannels uint32) (*AudioStream, *cgoAllocMap) {
	obj := *new(gAudioStream)
	obj.gSampleRate = cSampleRate
	obj.gSampleSize = cSampleSize
	obj.gChannels = cChannels

	ret0, alloc0 := obj.passRef()
	ret1 := (*AudioStream)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *AudioStream) Index(index int32) *AudioStream {
	ptr1 := (*AudioStream)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfAudioStreamValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *AudioStream) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*AudioStream) {
			a.Free()
		})
	}
}

// allocSoundMemory allocates memory for type C.Sound in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSoundMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSoundValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSoundValue = unsafe.Sizeof([1]C.Sound{})

// newSoundRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newSoundRef(ref unsafe.Pointer) *gSound {
	if ref == nil {
		return nil
	}
	obj := new(gSound)
	obj.ref394fec80 = (*C.Sound)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gSound) passRef() (*C.Sound, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref394fec80 != nil {
		if x.allocs394fec80 != nil {
			return x.ref394fec80, x.allocs394fec80.(*cgoAllocMap)
		} else {
			return x.ref394fec80, nil
		}
	}
	mem394fec80 := unsafe.Pointer(new(C.Sound))
	ref394fec80 := (*C.Sound)(mem394fec80)
	allocs394fec80 := new(cgoAllocMap)
	// allocs394fec80.Add(mem394fec80)

	var cstream_allocs *cgoAllocMap
	ref394fec80.stream, cstream_allocs = x.gStream.passValue()
	allocs394fec80.Borrow(cstream_allocs)
	x.gStream = *new(gAudioStream)

	var csampleCount_allocs *cgoAllocMap
	ref394fec80.sampleCount, csampleCount_allocs = (C.uint)(x.gSampleCount), cgoAllocsUnknown
	allocs394fec80.Borrow(csampleCount_allocs)
	x.gSampleCount = *new(uint32)

	x.ref394fec80 = ref394fec80
	x.allocs394fec80 = allocs394fec80

	return ref394fec80, allocs394fec80
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gSound) passValue() (C.Sound, *cgoAllocMap) {
	if x.ref394fec80 != nil {
		return *x.ref394fec80, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gSound) convert() *Sound {
	if x.ref394fec80 != nil {
		return (*Sound)(unsafe.Pointer(x.ref394fec80))
	}
	x.passRef()
	return (*Sound)(unsafe.Pointer(x.ref394fec80))
}

// NewSound new Go object and Mapping to C object.
func NewSound(cStream AudioStream, cSampleCount uint32) Sound {
	obj := *new(gSound)
	obj.gStream = *newAudioStreamRef(unsafe.Pointer(&cStream))
	obj.gSampleCount = cSampleCount

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocSound.")
	}
	return *(*Sound)(unsafe.Pointer(ret0))
}

// AllocSound new Go object and Mapping to C object.
func AllocSound(cStream AudioStream, cSampleCount uint32) (*Sound, *cgoAllocMap) {
	obj := *new(gSound)
	obj.gStream = *newAudioStreamRef(unsafe.Pointer(&cStream))
	obj.gSampleCount = cSampleCount

	ret0, alloc0 := obj.passRef()
	ret1 := (*Sound)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Sound) Index(index int32) *Sound {
	ptr1 := (*Sound)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfSoundValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Sound) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Sound) {
			a.Free()
		})
	}
}

// allocMusicMemory allocates memory for type C.Music in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMusicMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMusicValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMusicValue = unsafe.Sizeof([1]C.Music{})

// newMusicRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newMusicRef(ref unsafe.Pointer) *gMusic {
	if ref == nil {
		return nil
	}
	obj := new(gMusic)
	obj.refc930d4e = (*C.Music)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gMusic) passRef() (*C.Music, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc930d4e != nil {
		if x.allocsc930d4e != nil {
			return x.refc930d4e, x.allocsc930d4e.(*cgoAllocMap)
		} else {
			return x.refc930d4e, nil
		}
	}
	memc930d4e := unsafe.Pointer(new(C.Music))
	refc930d4e := (*C.Music)(memc930d4e)
	allocsc930d4e := new(cgoAllocMap)
	// allocsc930d4e.Add(memc930d4e)

	var cstream_allocs *cgoAllocMap
	refc930d4e.stream, cstream_allocs = x.gStream.passValue()
	allocsc930d4e.Borrow(cstream_allocs)
	x.gStream = *new(gAudioStream)

	var csampleCount_allocs *cgoAllocMap
	refc930d4e.sampleCount, csampleCount_allocs = (C.uint)(x.gSampleCount), cgoAllocsUnknown
	allocsc930d4e.Borrow(csampleCount_allocs)
	x.gSampleCount = *new(uint32)

	var clooping_allocs *cgoAllocMap
	refc930d4e.looping, clooping_allocs = (C._Bool)(x.gLooping), cgoAllocsUnknown
	allocsc930d4e.Borrow(clooping_allocs)
	x.gLooping = *new(bool)

	var cctxType_allocs *cgoAllocMap
	refc930d4e.ctxType, cctxType_allocs = (C.int)(x.gCtxType), cgoAllocsUnknown
	allocsc930d4e.Borrow(cctxType_allocs)
	x.gCtxType = *new(int32)

	var cctxData_allocs *cgoAllocMap
	refc930d4e.ctxData, cctxData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.gCtxData)), cgoAllocsUnknown
	allocsc930d4e.Borrow(cctxData_allocs)
	x.gCtxData = *new(unsafe.Pointer)

	x.refc930d4e = refc930d4e
	x.allocsc930d4e = allocsc930d4e

	return refc930d4e, allocsc930d4e
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gMusic) passValue() (C.Music, *cgoAllocMap) {
	if x.refc930d4e != nil {
		return *x.refc930d4e, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gMusic) convert() *Music {
	if x.refc930d4e != nil {
		return (*Music)(unsafe.Pointer(x.refc930d4e))
	}
	x.passRef()
	return (*Music)(unsafe.Pointer(x.refc930d4e))
}

// NewMusic new Go object and Mapping to C object.
func NewMusic(cStream AudioStream, cSampleCount uint32, cLooping bool, cCtxType int32, cCtxData unsafe.Pointer) Music {
	obj := *new(gMusic)
	obj.gStream = *newAudioStreamRef(unsafe.Pointer(&cStream))
	obj.gSampleCount = cSampleCount
	obj.gLooping = cLooping
	obj.gCtxType = cCtxType
	obj.gCtxData = cCtxData

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocMusic.")
	}
	return *(*Music)(unsafe.Pointer(ret0))
}

// AllocMusic new Go object and Mapping to C object.
func AllocMusic(cStream AudioStream, cSampleCount uint32, cLooping bool, cCtxType int32, cCtxData unsafe.Pointer) (*Music, *cgoAllocMap) {
	obj := *new(gMusic)
	obj.gStream = *newAudioStreamRef(unsafe.Pointer(&cStream))
	obj.gSampleCount = cSampleCount
	obj.gLooping = cLooping
	obj.gCtxType = cCtxType
	obj.gCtxData = cCtxData

	ret0, alloc0 := obj.passRef()
	ret1 := (*Music)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Music) Index(index int32) *Music {
	ptr1 := (*Music)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfMusicValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Music) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Music) {
			a.Free()
		})
	}
}

// allocVrDeviceInfoMemory allocates memory for type C.VrDeviceInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVrDeviceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVrDeviceInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVrDeviceInfoValue = unsafe.Sizeof([1]C.VrDeviceInfo{})

// newVrDeviceInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newVrDeviceInfoRef(ref unsafe.Pointer) *gVrDeviceInfo {
	if ref == nil {
		return nil
	}
	obj := new(gVrDeviceInfo)
	obj.ref6e24e41d = (*C.VrDeviceInfo)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gVrDeviceInfo) passRef() (*C.VrDeviceInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6e24e41d != nil {
		if x.allocs6e24e41d != nil {
			return x.ref6e24e41d, x.allocs6e24e41d.(*cgoAllocMap)
		} else {
			return x.ref6e24e41d, nil
		}
	}
	mem6e24e41d := unsafe.Pointer(new(C.VrDeviceInfo))
	ref6e24e41d := (*C.VrDeviceInfo)(mem6e24e41d)
	allocs6e24e41d := new(cgoAllocMap)
	// allocs6e24e41d.Add(mem6e24e41d)

	var chResolution_allocs *cgoAllocMap
	ref6e24e41d.hResolution, chResolution_allocs = (C.int)(x.gHResolution), cgoAllocsUnknown
	allocs6e24e41d.Borrow(chResolution_allocs)
	x.gHResolution = *new(int32)

	var cvResolution_allocs *cgoAllocMap
	ref6e24e41d.vResolution, cvResolution_allocs = (C.int)(x.gVResolution), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cvResolution_allocs)
	x.gVResolution = *new(int32)

	var chScreenSize_allocs *cgoAllocMap
	ref6e24e41d.hScreenSize, chScreenSize_allocs = (C.float)(x.gHScreenSize), cgoAllocsUnknown
	allocs6e24e41d.Borrow(chScreenSize_allocs)
	x.gHScreenSize = *new(float32)

	var cvScreenSize_allocs *cgoAllocMap
	ref6e24e41d.vScreenSize, cvScreenSize_allocs = (C.float)(x.gVScreenSize), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cvScreenSize_allocs)
	x.gVScreenSize = *new(float32)

	var cvScreenCenter_allocs *cgoAllocMap
	ref6e24e41d.vScreenCenter, cvScreenCenter_allocs = (C.float)(x.gVScreenCenter), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cvScreenCenter_allocs)
	x.gVScreenCenter = *new(float32)

	var ceyeToScreenDistance_allocs *cgoAllocMap
	ref6e24e41d.eyeToScreenDistance, ceyeToScreenDistance_allocs = (C.float)(x.gEyeToScreenDistance), cgoAllocsUnknown
	allocs6e24e41d.Borrow(ceyeToScreenDistance_allocs)
	x.gEyeToScreenDistance = *new(float32)

	var clensSeparationDistance_allocs *cgoAllocMap
	ref6e24e41d.lensSeparationDistance, clensSeparationDistance_allocs = (C.float)(x.gLensSeparationDistance), cgoAllocsUnknown
	allocs6e24e41d.Borrow(clensSeparationDistance_allocs)
	x.gLensSeparationDistance = *new(float32)

	var cinterpupillaryDistance_allocs *cgoAllocMap
	ref6e24e41d.interpupillaryDistance, cinterpupillaryDistance_allocs = (C.float)(x.gInterpupillaryDistance), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cinterpupillaryDistance_allocs)
	x.gInterpupillaryDistance = *new(float32)

	var clensDistortionValues_allocs *cgoAllocMap
	ref6e24e41d.lensDistortionValues, clensDistortionValues_allocs = *(*[4]C.float)(unsafe.Pointer(&x.gLensDistortionValues)), cgoAllocsUnknown
	allocs6e24e41d.Borrow(clensDistortionValues_allocs)
	x.gLensDistortionValues = *new([4]float32)

	var cchromaAbCorrection_allocs *cgoAllocMap
	ref6e24e41d.chromaAbCorrection, cchromaAbCorrection_allocs = *(*[4]C.float)(unsafe.Pointer(&x.gChromaAbCorrection)), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cchromaAbCorrection_allocs)
	x.gChromaAbCorrection = *new([4]float32)

	x.ref6e24e41d = ref6e24e41d
	x.allocs6e24e41d = allocs6e24e41d

	return ref6e24e41d, allocs6e24e41d
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gVrDeviceInfo) passValue() (C.VrDeviceInfo, *cgoAllocMap) {
	if x.ref6e24e41d != nil {
		return *x.ref6e24e41d, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gVrDeviceInfo) convert() *VrDeviceInfo {
	if x.ref6e24e41d != nil {
		return (*VrDeviceInfo)(unsafe.Pointer(x.ref6e24e41d))
	}
	x.passRef()
	return (*VrDeviceInfo)(unsafe.Pointer(x.ref6e24e41d))
}

// NewVrDeviceInfo new Go object and Mapping to C object.
func NewVrDeviceInfo(cHResolution int32, cVResolution int32, cHScreenSize float32, cVScreenSize float32, cVScreenCenter float32, cEyeToScreenDistance float32, cLensSeparationDistance float32, cInterpupillaryDistance float32, cLensDistortionValues [4]float32, cChromaAbCorrection [4]float32) VrDeviceInfo {
	obj := *new(gVrDeviceInfo)
	obj.gHResolution = cHResolution
	obj.gVResolution = cVResolution
	obj.gHScreenSize = cHScreenSize
	obj.gVScreenSize = cVScreenSize
	obj.gVScreenCenter = cVScreenCenter
	obj.gEyeToScreenDistance = cEyeToScreenDistance
	obj.gLensSeparationDistance = cLensSeparationDistance
	obj.gInterpupillaryDistance = cInterpupillaryDistance
	obj.gLensDistortionValues = cLensDistortionValues
	obj.gChromaAbCorrection = cChromaAbCorrection

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocVrDeviceInfo.")
	}
	return *(*VrDeviceInfo)(unsafe.Pointer(ret0))
}

// AllocVrDeviceInfo new Go object and Mapping to C object.
func AllocVrDeviceInfo(cHResolution int32, cVResolution int32, cHScreenSize float32, cVScreenSize float32, cVScreenCenter float32, cEyeToScreenDistance float32, cLensSeparationDistance float32, cInterpupillaryDistance float32, cLensDistortionValues [4]float32, cChromaAbCorrection [4]float32) (*VrDeviceInfo, *cgoAllocMap) {
	obj := *new(gVrDeviceInfo)
	obj.gHResolution = cHResolution
	obj.gVResolution = cVResolution
	obj.gHScreenSize = cHScreenSize
	obj.gVScreenSize = cVScreenSize
	obj.gVScreenCenter = cVScreenCenter
	obj.gEyeToScreenDistance = cEyeToScreenDistance
	obj.gLensSeparationDistance = cLensSeparationDistance
	obj.gInterpupillaryDistance = cInterpupillaryDistance
	obj.gLensDistortionValues = cLensDistortionValues
	obj.gChromaAbCorrection = cChromaAbCorrection

	ret0, alloc0 := obj.passRef()
	ret1 := (*VrDeviceInfo)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *VrDeviceInfo) Index(index int32) *VrDeviceInfo {
	ptr1 := (*VrDeviceInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfVrDeviceInfoValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *VrDeviceInfo) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*VrDeviceInfo) {
			a.Free()
		})
	}
}

// LensDistortionValues returns a reference to C object within a struct

// ChromaAbCorrection returns a reference to C object within a struct

// allocMultiTextMemory allocates memory for type C.MultiText in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMultiTextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMultiTextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMultiTextValue = unsafe.Sizeof([1]C.MultiText{})

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackSString transforms a sliced Go data structure into plain C format.
func unpackSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		var allocs0 *cgoAllocMap
		v0[i0], allocs0 = unpackMemoryPCharString(x[i0])
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// unpackMemoryPCharString represents the data from Go string as *C.char and avoids copying.
func unpackMemoryPCharString(str string) (*C.char, *cgoAllocMap) {
	ptr0 := C.CString(str)
	mem0 := unsafe.Pointer(ptr0)
	allocs0 := new(cgoAllocMap)
	allocs0.Add(mem0)
	return ptr0, allocs0
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// newMultiTextRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newMultiTextRef(ref unsafe.Pointer) *gMultiText {
	if ref == nil {
		return nil
	}
	obj := new(gMultiText)
	obj.refdf1ec495 = (*C.MultiText)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gMultiText) passRef() (*C.MultiText, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdf1ec495 != nil {
		if x.allocsdf1ec495 != nil {
			return x.refdf1ec495, x.allocsdf1ec495.(*cgoAllocMap)
		} else {
			return x.refdf1ec495, nil
		}
	}
	memdf1ec495 := unsafe.Pointer(new(C.MultiText))
	refdf1ec495 := (*C.MultiText)(memdf1ec495)
	allocsdf1ec495 := new(cgoAllocMap)
	// allocsdf1ec495.Add(memdf1ec495)

	var ctext_allocs *cgoAllocMap
	refdf1ec495.text, ctext_allocs = unpackSString(x.gText)
	allocsdf1ec495.Borrow(ctext_allocs)
	x.gText = *new([]string)

	x.refdf1ec495 = refdf1ec495
	x.allocsdf1ec495 = allocsdf1ec495

	return refdf1ec495, allocsdf1ec495
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gMultiText) passValue() (C.MultiText, *cgoAllocMap) {
	if x.refdf1ec495 != nil {
		return *x.refdf1ec495, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gMultiText) convert() *MultiText {
	if x.refdf1ec495 != nil {
		return (*MultiText)(unsafe.Pointer(x.refdf1ec495))
	}
	x.passRef()
	return (*MultiText)(unsafe.Pointer(x.refdf1ec495))
}

// NewMultiText new Go object and Mapping to C object.
func NewMultiText(cText []string) MultiText {
	obj := *new(gMultiText)
	obj.gText = cText

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocMultiText.")
	}
	return *(*MultiText)(unsafe.Pointer(ret0))
}

// AllocMultiText new Go object and Mapping to C object.
func AllocMultiText(cText []string) (*MultiText, *cgoAllocMap) {
	obj := *new(gMultiText)
	obj.gText = cText

	ret0, alloc0 := obj.passRef()
	ret1 := (*MultiText)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *MultiText) Index(index int32) *MultiText {
	ptr1 := (*MultiText)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfMultiTextValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *MultiText) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*MultiText) {
			a.Free()
		})
	}
}

// Text returns a reference to C object within a struct

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// unpackPUcharString represents the data from Go string as *C.uchar and avoids copying.
func unpackPUcharString(str string) (*C.uchar, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.uchar)(h.Data), cgoAllocsUnknown
}
